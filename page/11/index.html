<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">









  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.6" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.6">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.6" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.6',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Rongxuanhong&apos;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Rongxuanhong&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="Rongxuanhong&#39;s Blog">
<meta property="og:description" content="Rongxuanhong&apos;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rongxuanhong&#39;s Blog">
<meta name="twitter:description" content="Rongxuanhong&apos;s Blog">






  <link rel="canonical" href="http://yoursite.com/page/11/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Rongxuanhong's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rongxuanhong's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">脚踏实地地做好自己</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
</li>

      

      
    </ul>
  

  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/30/一起看画笔Paint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="洪荣宣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ww1.sinaimg.cn/large/8992ce25gy1fengvigdatj205k05k0t0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rongxuanhong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/30/一起看画笔Paint/" itemprop="url">一起看画笔Paint</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-30T19:23:25+08:00">2017-07-30</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/30/一起看画笔Paint/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments:</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/30/一起看画笔Paint/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>Paint</strong> 可以决定你所画的几何图形、文本、位图的样式和颜色变化。</p>
<h1 id="mPaint-measureXX"><a href="#mPaint-measureXX" class="headerlink" title="mPaint.measureXX"></a>mPaint.measureXX</h1><h2 id="mPaint-MeasureText"><a href="#mPaint-MeasureText" class="headerlink" title="mPaint.MeasureText"></a>mPaint.MeasureText</h2><ol>
<li><p>方法1： </p>
<pre><code> float measureText (char[] text, int index, int count) 
</code></pre><p>作用：测量文字绘制时所占用的宽度。<br>对参数的解释:  </p>
<ul>
<li>text 待测试的字符数组</li>
<li>index 从第几个index开始测量</li>
<li>count 共测量多少个字符  </li>
</ul>
</li>
<li><p>方法2:</p>
<pre><code> float measureText (CharSequence text, int start, int end) 
</code></pre><p>对参数的解释：  </p>
<ul>
<li>text 待测试字符串</li>
<li>start 从start位置开始测量字符串</li>
<li>end  测量到字符串的end位置，但不包括.</li>
</ul>
</li>
<li><p>方法3：</p>
<pre><code> float measureText (String text, int start, int end)
</code></pre></li>
<li><p>例子:  </p>
<pre><code> char[] str=&quot;学习Paint&quot;.toCharArray();
 String string=&quot;学习Paint&quot;;
 float v1 = mPaint.measureText(string);
 Log.i(TAG,&quot;方法1=&quot;+v1);//测量&quot;学习Paint&quot;
 float v2 = mPaint.measureText(str,0,str.length-1);//只测量&quot;学习Pain&quot;
 Log.i(TAG,&quot;方法2=&quot;+v2);
 float v3=mPaint.measureText(string,1,string.length());//只测量&quot;习Paint&quot;
 Log.i(TAG,&quot;方法3=&quot;+v3);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhn77x6w5xj20hm02zdfs.jpg" alt=""><br>另外：<strong>mPaint.getTextWidths(String text, float[] widths)</strong>用于获取 <strong>text</strong> 中每个字符的宽度并返回到 <strong>widths</strong> 数组中，用到了<code>MeasureText</code> 方法  </p>
</li>
</ol>
<h1 id="mPaint-breakXXX"><a href="#mPaint-breakXXX" class="headerlink" title="mPaint.breakXXX"></a>mPaint.breakXXX</h1><h2 id="mPaint-breakText"><a href="#mPaint-breakText" class="headerlink" title="mPaint.breakText"></a>mPaint.breakText</h2><p>作用:测量指定宽度的文本宽度，超过指定宽度后截断。  </p>
<ol>
<li><p>方法1:  </p>
<pre><code> breakText(String text, boolean measureForwards, float maxWidth, float[] measuredWidth)  
</code></pre></li>
<li><p>方法2:  </p>
<pre><code> breakText(char[] text, int index, int count, float maxWidth, float[] measuredWidth)  
</code></pre></li>
<li><p>方法3:  </p>
<pre><code> breakText(CharSequence text, int start, int end, boolean measureForwards, float maxWidth, float[] measuredWidth)  
</code></pre></li>
<li>关键参数详解：  </li>
</ol>
<ul>
<li><strong>measureForwards</strong>：表示文字测量的方法，<strong>true</strong> 表示从左向右开始测量.  </li>
<li><strong>maxWidth</strong>:指定要测量的文本的最大宽度，也是是否截断文本的界限值.</li>
<li><strong>measuredWidth</strong>:用于接受数据,并将结果赋值给 <strong>measuredWidth[0]</strong>  </li>
</ul>
<h1 id="mPaint-setXXX"><a href="#mPaint-setXXX" class="headerlink" title="mPaint.setXXX"></a>mPaint.setXXX</h1><h2 id="mPaint-set"><a href="#mPaint-set" class="headerlink" title="mPaint.set"></a>mPaint.set</h2><p>为当前画笔copy一支画笔  </p>
<h2 id="mPaint-setAlpha"><a href="#mPaint-setAlpha" class="headerlink" title="mPaint.setAlpha"></a>mPaint.setAlpha</h2><p>方法: </p>
<pre><code>void setAlpha (int a)  
</code></pre><p>为设置透明值属性，a介于[0,255]之间</p>
<h2 id="mPaint-setARGB"><a href="#mPaint-setARGB" class="headerlink" title="mPaint.setARGB"></a>mPaint.setARGB</h2><p>方法： </p>
<pre><code>void setARGB (int a, int r, int g, int b) 
</code></pre><p>设置透明值和三基色  </p>
<h2 id="mPaint-setAntiAlias"><a href="#mPaint-setAntiAlias" class="headerlink" title="mPaint.setAntiAlias"></a>mPaint.setAntiAlias</h2><p>方法： </p>
<pre><code>void setAntiAlias (boolean aa)  
</code></pre><p>设置是否开启抗锯齿</p>
<h2 id="mPaint-setColor"><a href="#mPaint-setColor" class="headerlink" title="mPaint.setColor"></a>mPaint.setColor</h2><p>方法: </p>
<pre><code>void setColor (int color)  
</code></pre><p>设置画笔的颜色</p>
<h2 id="mPaint-setColorFilter"><a href="#mPaint-setColorFilter" class="headerlink" title="mPaint.setColorFilter"></a>mPaint.setColorFilter</h2><p>方法: </p>
<pre><code>ColorFilter setColorFilter (ColorFilter filter)  
</code></pre><p>设置或清除画笔的颜色过滤器,比如去掉图片的绿色  </p>
<h3 id="ColorFilter"><a href="#ColorFilter" class="headerlink" title="ColorFilter"></a>ColorFilter</h3><p>有三个子类可供设置  </p>
<ol>
<li><p><strong>LightingColorFilter</strong><br>作用：常用于模拟灯光效果<br>构造方法：</p>
<p> LightingColorFilter(int mul, int add) </p>
</li>
</ol>
<p>对参数的解释：  </p>
<pre><code>mul: 色彩倍增值,16进制的色彩值0xAARRGGBB。
add: 色彩增加值,16进制的色彩值0xAARRGGBB。  
</code></pre><p>计算公式:  </p>
<pre><code>     R&#39; = R * colorMultiply.R + colorAdd.R
     G&#39; = G * colorMultiply.G + colorAdd.G
     B&#39; = B * colorMultiply.B + colorAdd.B  
</code></pre><p>由16进制的与运算我们知道，任意的 <strong>0xAARRGGBB*0xFFFFFFFF=0xAARRGGBB</strong>,而再加上<strong>0x00000000</strong>，结果仍不变。故我们知道当 <strong>mul=0xFFFFFFFF,add=0x00000000</strong>,该过滤器并不会改变原图的色调。如果我们要增加绿色的值，我们就可以修改 <strong>add</strong> 的值为 <strong>0x0000XX00</strong>(其中 <strong>xx</strong> 介于 <strong>00-FF</strong> 之间);如果我们要去掉绿色的值,我们就可以修改 <strong>mul</strong> 中 <strong>xx</strong> 的值。总之，去掉某个颜色修改 <strong>mul</strong> 值，增加某个颜色值修改 <strong>add</strong>。<br>例子:  </p>
<pre><code>    LightingColorFilter filter1=new LightingColorFilter(0xFFFFFFFF,0x00000000);
    LightingColorFilter filter2=new LightingColorFilter(0xFFFF00FF,0x00000000);
    LightingColorFilter filter3=new LightingColorFilter(0xFFFFFFFF,0x0000FF00);
    Bitmap panda= BitmapFactory.decodeResource(getResources(), R.drawable.images);
    mPaint.setColorFilter(filter1);
    canvas.drawBitmap(panda,20,20,mPaint);
    mPaint.reset();
    mPaint.setColorFilter(filter2);
    canvas.drawBitmap(panda,20,25+panda.getHeight(),mPaint);
    mPaint.reset();
    mPaint.setColorFilter(filter3);
    canvas.drawBitmap(panda,20,30+panda.getHeight()*2,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhn800mll5j20bc0j7gt9.jpg" alt="">  </p>
<ol>
<li><strong>ColorMatrixColorFilter</strong><br>作用：通过 <strong>4*5</strong> 颜色矩阵来改善中像素的饱满度  </li>
</ol>
<p>构造方法1:</p>
<pre><code>ColorMatrixColorFilter(ColorMatrix matrix)
</code></pre><p><strong>ColorMatrix</strong> 可改变 <strong>bitmap</strong> 上的颜色和透明度（变换 <strong>RGBA</strong> 的值，达到改变的目的）,可以以一组 <strong>4*5</strong> 的数组构建该对象<br>构造方法2:</p>
<pre><code>ColorMatrixColorFilter (float[] array)  
</code></pre><p>假设颜色矩阵为  </p>
<pre><code>    [ a, b, c, d, e,  
    f, g, h, i, j,  
    k, l, m, n, o,  
    p, q, r, s, t ]   
</code></pre><p>则计算公式为:  </p>
<pre><code>   R’ = a*R + b*G + c*B + d*A + e;  
   G’ = f*R + g*G + h*B + i*A + j;  
   B’ = k*R + l*G + m*B + n*A + o;  
   A’ = p*R + q*G + r*B + s*A + t;   
</code></pre><p>由矩阵相乘的原理可知，任何一个矩阵与单位矩阵相乘仍为本身(不懂去补矩阵基础知识)。那么现在类比 <strong>LightingColorFilter</strong> 的计算公式，你是否发现了点什么？没错，颜色矩阵的前 <strong>4</strong> 列(<strong>必须按顺序</strong>)采用的值产生效果与颜色倍增一致，而最后一列与颜色增加的效果一致, 接下来我们修改颜色矩阵，使之和上图中的效果一致。<br>例子：  </p>
<pre><code>    ColorMatrixColorFilter filter1 = new ColorMatrixColorFilter(new float[]{
            1, 0, 0, 0, 0,
            0, 1, 0, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 0, 1, 0
    });
    ColorMatrixColorFilter filter2 = new ColorMatrixColorFilter(new float[]{
            1, 0, 0, 0, 0,
            0, 0, 0, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 0, 1, 0
    });
    ColorMatrixColorFilter filter3 = new ColorMatrixColorFilter(new float[]{
            1, 0, 0, 0, 0,
            0, 1, 0, 0, 255,
            0, 0, 1, 0, 0,
            0, 0, 0, 1, 0
    });  
</code></pre><ol>
<li><p><strong>PorterDuffColorFilter</strong><br>作用：通过使用单颜色或 <strong>Porter-Duff</strong> 组合模式来为源像素着色<br>实例：  </p>
<p> setColorFilter(Color.parseColor(“#99000000”), PorterDuff.Mode.DARKEN);<br> 可设置ImageView的前景色为透明黑<br>构造方法:</p>
<p> PorterDuffColorFilter(int color, PorterDuff.Mode mode)<br>对参数的解释:  </p>
</li>
</ol>
<ul>
<li><strong>color</strong>:<strong>16</strong> 进制 <strong>ARGB</strong> 值</li>
<li><strong>mode</strong>:指定的 <strong>PorterDuff.Mode</strong>(<strong>这里主要是图像色彩混和</strong>)。共有 <strong>5</strong> 种，分别是<strong>Darken(变暗)、Lighten(变亮)、Multiply(正片叠底)、Overlay(重叠)、Screen(滤色)</strong>，预知各种模式详解请耐心继续往下看。  </li>
</ul>
<p>例子:  </p>
<pre><code>    PorterDuffColorFilter filter1=new PorterDuffColorFilter(0xFFFF0000, PorterDuff.Mode.DARKEN);
    PorterDuffColorFilter filter2=new PorterDuffColorFilter(0xFFFF0000, PorterDuff.Mode.MULTIPLY);
    PorterDuffColorFilter filter3=new PorterDuffColorFilter(0xFFFF0000, PorterDuff.Mode.SCREEN);
    PorterDuffColorFilter filter4=new PorterDuffColorFilter(0xFFFF0000, PorterDuff.Mode.LIGHTEN);
    PorterDuffColorFilter filter5=new PorterDuffColorFilter(0xFFFF0000, PorterDuff.Mode.OVERLAY);
    Bitmap panda= BitmapFactory.decodeResource(getResources(), R.drawable.images);
    mPaint.setColorFilter(filter1);
    canvas.drawBitmap(panda,20,10,mPaint);
    mPaint.setColorFilter(filter2);
    canvas.drawBitmap(panda,20,15+panda.getHeight(),mPaint);
    mPaint.setColorFilter(filter3);
    canvas.drawBitmap(panda,20,20+panda.getHeight()*2,mPaint);
    mPaint.setColorFilter(filter4);
    canvas.drawBitmap(panda,20,25+panda.getHeight()*3,mPaint);
    mPaint.setColorFilter(filter5);
    canvas.drawBitmap(panda,20,30+panda.getHeight()*4,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhn9esio0sj20ay0qjn5v.jpg" alt=""></p>
<h2 id="mPaint-setDither"><a href="#mPaint-setDither" class="headerlink" title="mPaint.setDither"></a>mPaint.setDither</h2><p>方法：</p>
<pre><code>void setDither (boolean dither)  
</code></pre><p>作用：设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰。其实当下智能手机也有运动防抖功能，只要你用过一定知道区别。</p>
<h2 id="mPaint-setFakeBoldText"><a href="#mPaint-setFakeBoldText" class="headerlink" title="mPaint.setFakeBoldText"></a>mPaint.setFakeBoldText</h2><p>方法:</p>
<pre><code>void setFakeBoldText (boolean fakeBoldText)     
</code></pre><p>设置伪粗体文本,与设置 <strong>FAKE_BOLD_TEXT_FLAG</strong> 一样,只是一种文本显示效果而已，咱不深究。  </p>
<h2 id="mPaint-setFilterBitmap"><a href="#mPaint-setFilterBitmap" class="headerlink" title="mPaint.setFilterBitmap"></a>mPaint.setFilterBitmap</h2><p>方法:</p>
<pre><code>void setFilterBitmap (boolean filter)    
</code></pre><p>设置位图进行<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2" target="_blank" rel="noopener">滤波</a>(<strong>Filter</strong>)处理  </p>
<h2 id="mPaint-setHinting"><a href="#mPaint-setHinting" class="headerlink" title="mPaint.setHinting"></a>mPaint.setHinting</h2><p>方法：</p>
<pre><code>void setHinting (int mode)  
</code></pre><p> 设置字体微调, 可以是 <strong>HINTING_OFF or HINTING_ON</strong>. 由于当今手机密度高，此方法已无用武之地，略过。</p>
<h2 id="mPaint-setLetterSpacing"><a href="#mPaint-setLetterSpacing" class="headerlink" title="mPaint.setLetterSpacing"></a>mPaint.setLetterSpacing</h2><p>方法:</p>
<pre><code>void setLetterSpacing (float letterSpacing)     
</code></pre><p>设置文本的字符间距，默认值为0，负数值会缩紧文本。注意文字本身两侧默认有间隙  </p>
<h2 id="mPaint-setLinearText"><a href="#mPaint-setLinearText" class="headerlink" title="mPaint.setLinearText"></a>mPaint.setLinearText</h2><p>方法:</p>
<pre><code>void setLinearText (boolean linearText)  
</code></pre><p>设置文本为线性排列  </p>
<h2 id="mPaint-setMaskFilter"><a href="#mPaint-setMaskFilter" class="headerlink" title="mPaint.setMaskFilter"></a>mPaint.setMaskFilter</h2><ol>
<li><p>方法: </p>
<pre><code> MaskFilter setMaskFilter (MaskFilter maskfilter)   
</code></pre><p>设置或清除滤镜效果,传入 <strong>null</strong> 可清除之前的滤镜效果,<strong>maskfilter</strong> 由两个子类  <strong>BlurMaskFilter</strong>、<strong>EmbossMaskFilter</strong>所构造.</p>
</li>
<li><p><strong>BlurMaskFilter</strong> 模糊滤镜<br>构造方法:</p>
<pre><code> BlurMaskFilter(float radius, BlurMaskFilter.Blur style)    
</code></pre><p>对参数的解释:  </p>
<ul>
<li><strong>radius</strong>:设置显示的阴影半径,必须大于<strong>0</strong>  </li>
<li><strong>style</strong>:待应用的阴影模式  </li>
<li><strong>INNER</strong>:绘制内阴影和图片内容本身，不绘制外阴影</li>
<li><strong>NORMAL</strong>:正常阴影效果</li>
<li><strong>OUTER</strong>:不绘制内部阴影及图片内容，只绘制外阴影</li>
<li><strong>SOLID</strong>:只绘制外部阴影和图片内容，不绘制内阴影，与 <strong>INNER</strong> 相对  </li>
</ul>
</li>
<li><p><strong>EmbossMaskFilter</strong> 浮雕滤镜<br>构造方法:</p>
<pre><code>EmbossMaskFilter(float[] direction, float ambient, float specular, float blurRadius)    
</code></pre><p>对参数的解释:  </p>
<ul>
<li><strong>direction</strong>:指定光源的方向，由3个量构成的[x,y,z]设置 </li>
<li><strong>ambient</strong>:背景光的亮度，取值区间[0,1],决定背景的明暗程度</li>
<li><strong>specular</strong>:高光系数,值越小反射越强,那么亮度也相对偏亮</li>
<li><strong>blurRadius</strong>:阴影延伸半径  </li>
</ul>
</li>
<li><p>例子:  </p>
<pre><code> mPaint.setMaskFilter(new BlurMaskFilter(5, BlurMaskFilter.Blur.NORMAL));
 mPaint.setMaskFilter(new EmbossMaskFilter(new float[]{1,1,1},0.5f,8f,3f));  
</code></pre></li>
</ol>
<ul>
<li><strong>BlurMaskFilter.Blur.NORMAL</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhoe7ni5t5j20ax080q66.jpg" alt="">  </li>
<li><strong>BlurMaskFilter.Blur.INNER</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhoeapo9rqj20ar08j0vy.jpg" alt="">  </li>
<li><strong>BlurMaskFilter.Blur.OUTER</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhoeby4g1gj20b708gadb.jpg" alt="">  </li>
<li><strong>BlurMaskFilter.Blur.SOLID</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhoedtl4a3j20ba08iwhq.jpg" alt="">  </li>
<li>浮雕滤镜效果(可自个手动调值，感受下效果差异)<br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhoenuv7gdj20az08stby.jpg" alt=""></li>
</ul>
<h2 id="mPaint-setPathEffect"><a href="#mPaint-setPathEffect" class="headerlink" title="mPaint.setPathEffect"></a>mPaint.setPathEffect</h2><ol>
<li><p>方法:</p>
<pre><code> PathEffect setPathEffect (PathEffect effect)  
</code></pre><p>设置或清除路径效果，传入 <strong>null</strong>清除效果<br><strong>PathEffect</strong> 共有 <strong>6</strong> 个子类可用于构造对象，然后作为方法参数传入  </p>
</li>
<li><p><strong>CornerPathEffect</strong><br>构造方法:</p>
<pre><code> CornerPathEffect (float radius)
</code></pre><p>改变线段之间的圆滑度，而不是带锐角的折线形式<br>对参数的解释:  </p>
<ul>
<li><strong>radius</strong>:线段之间的圆滑程度    </li>
</ul>
</li>
<li><p><strong>DashPathEffect</strong><br>构造方法:</p>
<pre><code>DashPathEffect (float[] intervals, float phase)   
</code></pre><p>设置路径的虚线效果,<strong>setStroke</strong> 控制虚线的厚薄度<br>对参数的解释:  </p>
<ul>
<li><strong>interval</strong>:间隔数组，控制虚线的长度,其中第一个偶数指数即 <strong>0</strong> 所对应的值(至少为 <strong>2</strong> )表示第一条实线的长度，第一个奇数指数即 <strong>1</strong> 所对应的值表示第一条虚线的长度,第二个偶数对应实线，第二个奇数对应虚线…以此类推。数组不再由新元素，则开始从第一个数循环。  </li>
<li><strong>phase</strong>: 虚实线间的间距。  </li>
</ul>
<p>此类妙用:  当虚实线的长度为整个 <strong>path</strong> 的长度时，即 <strong>intervals</strong> 数组中仅有两个相等的元素且均为 <strong>path</strong> 长度时,虚实线的间距为 <strong>0</strong>,绘制出来的效果就是一条完整的实线。而虚实线的间距如果为 <strong>0</strong>到 <strong>path</strong> 长度之间动态变化（可借助值动画动态得到<strong>【0，1】</strong>之间变化的比例），那么就会出现类似沿着路径绘制的动画效果。</p>
</li>
<li><p><strong>DiscretePathEffect</strong><br>构造方法：</p>
<pre><code> DiscretePathEffect (float segmentLength, float deviation)  
</code></pre><p>设置离散的路径效果<br>对参数的解释:  </p>
<ul>
<li><strong>segmentLength</strong> :离散片段的长度</li>
<li><strong>deviation</strong>： 随机的偏移原路径的值    </li>
</ul>
</li>
<li><p><strong>PathDashPathEffect</strong><br>构造方法:</p>
<pre><code> PathDashPathEffect (Path shape, float advance, float phase, PathDashPathEffect.Style style)  
</code></pre><p>用指定的路径形状对所画的路径进行虚线化标记,<strong>与顺序有关</strong>。<br>对参数的理解:  </p>
<ul>
<li><strong>shape</strong>:虚线段的路径形状  </li>
<li><strong>advance</strong>:实线的间隔，即长度</li>
<li><strong>phase</strong>:虚实线间的间距  </li>
<li><strong>style</strong>:由 <strong>NOMAL,ROTATE,TRANSLATES</strong> 三种样式    </li>
</ul>
</li>
<li><p><strong>SumPathEffect</strong><br>构造方法：</p>
<pre><code> SumPathEffect(PathEffect first, PathEffect second)  
</code></pre><p>逐一组合路径效果，<strong>与顺序无关</strong>。<br>对参数的理解:  </p>
<ul>
<li><strong>first</strong>:第一个路径效果  </li>
<li><strong>second</strong>: 第二个路径效果  </li>
</ul>
</li>
<li><p><strong>ComposePathEffect</strong><br>构造方法:</p>
<pre><code> ComposePathEffect (PathEffect outerpe, PathEffect innerpe)  
</code></pre><p>先指定一个内部路径效果，再指定一个外部路径效果，再将二者组合形成新的路径效果。  </p>
</li>
<li><p>例子:  </p>
<pre><code> public class DrawPractice extends View {
 private Paint mPaint = new Paint();
 public static final String TAG = &quot;DrawPractice&quot;;
 private PathEffect[] mPathEffects = new PathEffect[9];
 private  Path path;

 //省略构造函数
 private void init() {
     mPaint.setColor(Color.BLUE);
     mPaint.setAntiAlias(true);
     mPaint.setStyle(Paint.Style.STROKE);
     mPaint.setStrokeWidth(5);
     initPath();
 }

 private void initPath() {
 path = new Path();
 path.moveTo(20, 50);//路线起点

 for (int i = 0; i &lt;= 30; i++) {//随机生成折线
     path.lineTo(i * 35, (float) (Math.random() * 100));
 }
     mPathEffects[0]=null;
     mPathEffects[1]=new CornerPathEffect(5);
     mPathEffects[2]=new DashPathEffect(new float[]{20,10,5,1},5);
     mPathEffects[3]=new DiscretePathEffect(10,5);
     Path mPath=new Path();
     mPath.addRect(0,0,10,10, Path.Direction.CCW);
     mPathEffects[4]=new PathDashPathEffect(mPath,20,5f,PathDashPathEffect.Style.ROTATE);
      //注意5，6的区别 详细看图
     mPathEffects[5]=new ComposePathEffect(mPathEffects[1],mPathEffects[4]);
     mPathEffects[6]=new ComposePathEffect(mPathEffects[4],mPathEffects[1]);
     //7,8其实没区别  详细看图
     mPathEffects[7]=new SumPathEffect(mPathEffects[1],mPathEffects[4]);
     mPathEffects[8]=new SumPathEffect(mPathEffects[4],mPathEffects[1]);
 }

 @Override
 protected void onDraw(Canvas canvas) {
     super.onDraw(canvas);
 for (int i = 0; i &lt;mPathEffects.length ; i++) {
     mPaint.setPathEffect(mPathEffects[i]);
     canvas.drawPath(path,mPaint);
     canvas.translate(0,100);
     }
 }
 }  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhogedferpj20fe0gr0ul.jpg" alt="">  </p>
</li>
</ol>
<h2 id="mPaint-setShader"><a href="#mPaint-setShader" class="headerlink" title="mPaint.setShader"></a>mPaint.setShader</h2><ol>
<li><p>方法:</p>
<pre><code> Shader setShader (Shader shader)    
</code></pre><p>设置着色器,传入<strong>null</strong>清除<br>对参数的解释:  </p>
<ul>
<li><strong>shader</strong>:由 <strong>Shader</strong> 的五个子类构造传入,下面介绍。  </li>
</ul>
</li>
<li><p><strong>BitmapShader</strong><br>构造方法:</p>
<pre><code>     BitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY)    
</code></pre><p>作用:渲染位图<br>对参数的解释:  </p>
<ul>
<li><strong>bitmap</strong>: 位图  </li>
<li><strong>tileX</strong>:水平方向的一种模式</li>
<li><strong>tileY</strong>:竖直方向的一种模式<br>三种模式:    </li>
<li><strong>Shader.TileMode.CLAMP</strong>:重复水平或者竖直方向上位图的边缘颜色  </li>
<li><strong>Shader.TileMode.MIRROR</strong>:水平或者竖直方向上重复图片的镜像，并且连接处看似无缝对接  </li>
<li><p><strong>Shader.TileMode.REPEAT</strong>:水平或者竖直方向上重复图片<br>例子:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  Bitmap panda = BitmapFactory.decodeResource(getResources(), R.drawable.images);
  mPaint.setShader(new BitmapShader(panda, Shader.TileMode.CLAMP, Shader.TileMode.REPEAT));
  canvas.drawCircle(300,300,300,mPaint);
  mPaint.setShader(new BitmapShader(panda, Shader.TileMode.MIRROR, Shader.TileMode.REPEAT));
  canvas.drawCircle(300,900,300,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhqm0vzgfsj20eh0qfk6r.jpg" alt="">  </p>
</li>
</ul>
</li>
<li><p><strong>LinearGradient</strong><br>作用:设置一个沿着直线的线性渐变效果<br>构造方法1:</p>
<pre><code>     LinearGradient (float x0, 
             float y0, 
             float x1, 
             float y1, 
             int[] colors, 
             float[] positions, 
             Shader.TileMode tile)    
</code></pre><p>对参数的解释:    </p>
<ul>
<li><strong>x0,y0,x1,y1</strong>:渐变直线的起点和终点  </li>
<li><strong>colors</strong>:用于产生渐变效果的颜色组,非空 ，至少两种颜色</li>
<li><strong>positions</strong>:可为空,控制颜色数组不均匀的渐变，取值[0..1] </li>
<li><strong>tile</strong>:仍旧有三种模式可设置见上<br>构造方法2：<pre><code>  LinearGradient(float x0, float y0, float x1, float y1, int color0, int color1, Shader.TileMode tile)  
</code></pre>对参数的解释:  </li>
<li><strong>color0</strong>:渐变的起始颜色</li>
<li><p><strong>color1</strong>:渐变的终止颜色<br>例子:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(10);
  mPaint.setShader(new LinearGradient(0,0,500,500, 
                  new int[]{R.color.colorPrimaryDark, Color.BLUE},null,Shader.TileMode.CLAMP));
  canvas.drawRect(new RectF(20,20,200,200),mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhqmatix89j208409cq2s.jpg" alt="">  </p>
</li>
</ul>
</li>
<li><p><strong>RadialGradient</strong><br>作用:产生辐射状的渐变效果<br>构造方法1: </p>
<pre><code>     RadialGradient (float centerX, 
             float centerY, 
             float radius, 
             int[] colors, 
             float[] stops, 
             Shader.TileMode tileMode)    
</code></pre><p>对参数的解释：  </p>
<ul>
<li><strong>centerX,centerY</strong>:辐射的中心坐标</li>
<li><strong>radius</strong>:辐射半径</li>
<li><strong>colors</strong>:渐变颜色数组，至少两种颜色</li>
<li><strong>stops</strong>:可为空,控制颜色数组不均匀的渐变，取值[0..1]<br>构造方法2:  <pre><code>  RadialGradient (float centerX, 
          float centerY, 
          float radius, 
          int centerColor, 
          int edgeColor, 
          Shader.TileMode tileMode)    
</code></pre>对参数的解释:  </li>
<li><strong>centerColor</strong>: 辐射中心的颜色  </li>
<li><p><strong>edgeColor</strong>:辐射边缘的颜色<br>例子:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setShader(new RadialGradient(300,300,300, Color.RED, Color.BLUE,Shader.TileMode.CLAMP));
  canvas.drawCircle(200,300,200,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhqmf8oa30j20ac0d8myi.jpg" alt="">  </p>
</li>
</ul>
</li>
<li><p><strong>SweepGradient</strong><br>作用:绕中心顺时针旋转360度渐变<br>构造方法1: </p>
<pre><code>     SweepGradient (float cx, 
             float cy, 
             int[] colors, 
             float[] positions)    
</code></pre><p>对参数的解释：  </p>
<ul>
<li><strong>cx,cy</strong>: 旋转中心坐标</li>
<li><strong>colors</strong>:渐变颜色数组，至少两种颜色</li>
<li><strong>positions</strong>:可为空,控制颜色数组不均匀的渐变，取值[0..1]<br>构造方法2:  <pre><code>  SweepGradient (float cx, 
          float cy, 
          int color0, 
          int color1)    
</code></pre>对参数的解释:  </li>
<li><strong>color0</strong>: 渐变的起始颜色 </li>
<li><p><strong>color1</strong>:渐变的终止颜色<br>例子:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setShader(new SweepGradient(300,300 ,Color.RED, Color.BLUE));
  canvas.drawCircle(200,300,200,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhqmgoged8j20al0dg0tz.jpg" alt="">  </p>
</li>
</ul>
</li>
<li><p><strong>ComposeShader</strong><br>作用:用指定的模式组合两个渐变效果<br>构造方法1: </p>
<pre><code>     ComposeShader (Shader shaderA, 
             Shader shaderB, 
             Xfermode mode)    
</code></pre><p>对参数的解释：  </p>
<ul>
<li><strong>shaderA,shaderB</strong>: 要组合的两个渐变 <strong>shader</strong>  </li>
<li><strong>Xfermode mode</strong>:设置两张图片相交时的混合模式，与<strong>mPaint.setXfermode()</strong>一样<br>构造方法2:  <pre><code>      ComposeShader (Shader shaderA, 
          Shader shaderB, 
          PorterDuff.Mode mode)  
</code></pre>对参数的解释:  </li>
<li><p><strong>PorterDuff.Mode mode</strong>:设置两张图片相交时的混合规则<br>例子：  </p>
<pre><code>  BitmapShader shader = new BitmapShader(BitmapFactory.decodeResource(getResources(), R.drawable.images), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
  BitmapShader shader1 = new BitmapShader(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
  mPaint.setShader(new ComposeShader(shader, shader1, PorterDuff.Mode.SRC_OVER));
  canvas.drawCircle(50, 50, 50, mPaint);    
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhrvcznt4oj207y07vgln.jpg" alt="">    </p>
</li>
</ul>
</li>
</ol>
<p><strong>PorterDuffXfermode</strong>(<strong>XferMode</strong> 子类)<br>构造方法: </p>
<pre><code>    PorterDuffXfermode(PorterDuff.Mode mode)  
</code></pre><p>作用：指定一个 <strong>PorterDuff</strong>规则创建Xfermode实例<br><a href="http://www.jianshu.com/p/d11892bbe055" target="_blank" rel="noopener">PorterDuff.Mode使用详解看这</a></p>
<h2 id="mPaint-setShaderLayer"><a href="#mPaint-setShaderLayer" class="headerlink" title="mPaint.setShaderLayer"></a>mPaint.setShaderLayer</h2><ol>
<li><p>方法:  </p>
<pre><code> void setShadowLayer (float radius, float dx, float dy, int shadowColor)
</code></pre><p>作用:在主图层下添加阴影效果<br>对参数的解释:  </p>
<ul>
<li><strong>radius</strong>:设置显示阴影的半径</li>
<li><strong>dx,dy</strong>:基准点</li>
<li><strong>shadowColor</strong>:用于生成阴影的颜色<br>注意点：为文字加阴影不需要关闭硬件加速，否则都需要开启，方可显示效果。</li>
</ul>
</li>
<li><p>例子：  </p>
<pre><code> mPaint.setColor(Color.BLUE);
 mPaint.setTextSize(20);
 mPaint.setShadowLayer(50,50,50, Color.RED);
 canvas.drawText(&quot;看主图层下面的阴影效果&quot;,50,50,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhrvkk5fmzj209907ua9z.jpg" alt="">  </p>
</li>
</ol>
<h2 id="mPaint-setStrikeThruText"><a href="#mPaint-setStrikeThruText" class="headerlink" title="mPaint.setStrikeThruText"></a>mPaint.setStrikeThruText</h2><ol>
<li><p>方法:  </p>
<pre><code> void setStrikeThruText (boolean strikeThruText)
</code></pre></li>
<li>作用:设置删除线,与 <strong>setFlag(STRIKE_THRU_TEXT_FLAG)</strong>同等效果<br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhruzmonnjj206t06xa9y.jpg" alt="">  </li>
</ol>
<h2 id="mPaint-setStrokeCap"><a href="#mPaint-setStrokeCap" class="headerlink" title="mPaint.setStrokeCap"></a>mPaint.setStrokeCap</h2><ol>
<li><p>方法:  </p>
<pre><code> void setStrokeCap (Paint.Cap cap)  
</code></pre></li>
<li>作用：当画笔的样式是 <strong>Stroke</strong> 或者 <strong>StrokeAndFill</strong>，可改变画笔的笔头样式，比如圆形的笔头(<strong>Cap.ROUND</strong>)、方形的笔头(<strong>Cap.SQUARE</strong>)  </li>
<li>例子:<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhqrwi1ljlj208r0a0dfn.jpg" alt=""><br>从左到右分别为 <strong>BUTT(默认)、ROUND、SQUARE</strong>。其中后两条线前后均会超出上下的基线，并且形状各异，很像戴了个帽子(<strong>Cap</strong>)。</li>
</ol>
<h2 id="mPaint-setStrokeJoin"><a href="#mPaint-setStrokeJoin" class="headerlink" title="mPaint.setStrokeJoin"></a>mPaint.setStrokeJoin</h2><ol>
<li><p>方法:  </p>
<pre><code> void setStrokeJoin (Paint.Join join)  
</code></pre><p>作用:当画笔的样式是 <strong>Stroke</strong> 或者 <strong>StrokeAndFill</strong>,可改变画笔在转弯时候的样式,锐角、斜切、圆角处理。 </p>
</li>
<li>例子:<br><a href="http://blog.csdn.net/hnulwt/article/details/42705895" target="_blank" rel="noopener">Cap 与 Join 详解</a><br>从左到右分别是 <strong>MITER,BEVEL,ROUND;</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhqrk7lvhxj20de088glf.jpg" alt="">  </li>
</ol>
<h2 id="mPaint-setStrokeMiter"><a href="#mPaint-setStrokeMiter" class="headerlink" title="mPaint.setStrokeMiter"></a>mPaint.setStrokeMiter</h2><ol>
<li><p>方法:  </p>
<pre><code> void setStrokeMiter (float miter)  
</code></pre></li>
<li>作用：当画笔的样式是 <strong>Stroke</strong> 或者 <strong>StrokeAndFill</strong>,控制斜接连接处的角度，值必须大于等于 <strong>0</strong>，即控制Paint.Join.Miter的效果</li>
</ol>
<h2 id="mPaint-setStrokeWidth"><a href="#mPaint-setStrokeWidth" class="headerlink" title="mPaint.setStrokeWidth"></a>mPaint.setStrokeWidth</h2><ol>
<li><p>方法:  </p>
<pre><code> void setStrokeWidth (float width)  
</code></pre></li>
<li>作用:设置画笔的粗细程度    </li>
</ol>
<h2 id="mPaint-setStyle"><a href="#mPaint-setStyle" class="headerlink" title="mPaint.setStyle"></a>mPaint.setStyle</h2><ol>
<li><p>方法:  </p>
<pre><code> void setStyle (Paint.Style style)  
</code></pre></li>
<li>作用:控制画笔的样式模式,有仅填充(<strong>Paint.Style.Fill</strong>),描边且填充(<strong>Paint.Style.FILL_AND_STROKE</strong>),仅描边(<strong>Paint.Style.STROKE</strong>),简单地说，就是空心还是实心。  </li>
</ol>
<h2 id="mPaint-setSubpixelText"><a href="#mPaint-setSubpixelText" class="headerlink" title="mPaint.setSubpixelText"></a>mPaint.setSubpixelText</h2><ol>
<li><p>方法:  </p>
<pre><code> void setSubpixelText (boolean subpixelText)  
</code></pre></li>
<li>作用:有助于文本在LCD屏幕上的显示效果.但由于当今手机密度高,此方法已无用武之地,略过。  </li>
</ol>
<h2 id="mPaint-setTextAlign"><a href="#mPaint-setTextAlign" class="headerlink" title="mPaint.setTextAlign"></a>mPaint.setTextAlign</h2><ol>
<li><p>方法:  </p>
<pre><code> void setTextAlign (Paint.Align align)  
</code></pre><p>作用：设置文本的对齐方式,以有文本第一个字为基准靠左(<strong>Paint.Align.LEFT</strong>),居中(<strong>Paint.Align.CENTER</strong>),以文本最后一个字为基准靠右(<strong>Paint.Align.RIGHT</strong>)。  </p>
</li>
<li>例子:  </li>
</ol>
<h2 id="mPaint-setTextLocale"><a href="#mPaint-setTextLocale" class="headerlink" title="mPaint.setTextLocale"></a>mPaint.setTextLocale</h2><ol>
<li><p>方法：  </p>
<pre><code> void setTextLocale (Locale locale)  
</code></pre></li>
<li><p>作用：指定字体所使用的语言,例如<strong>Local.CHINA</strong>  </p>
</li>
</ol>
<h2 id="mPaint-setTextScaleX"><a href="#mPaint-setTextScaleX" class="headerlink" title="mPaint.setTextScaleX"></a>mPaint.setTextScaleX</h2><ol>
<li><p>方法：  </p>
<pre><code> void setTextScaleX (float scaleX)  
</code></pre></li>
<li>作用:设置文本的缩放比，默认为 <strong>1</strong>.值大于 <strong>1</strong>文本变宽，值小于 <strong>1</strong> 值变窄   </li>
<li>例子:  </li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhruojcqu2j20a308yt8u.jpg" alt=""></p>
<h2 id="mPaint-setTextSize"><a href="#mPaint-setTextSize" class="headerlink" title="mPaint.setTextSize"></a>mPaint.setTextSize</h2><ol>
<li><p>方法:  </p>
<pre><code> void setTextSize (float textSize)  
</code></pre></li>
<li>作用:设置文本的字体大小  </li>
</ol>
<h2 id="mPaint-setTextSkewX"><a href="#mPaint-setTextSkewX" class="headerlink" title="mPaint.setTextSkewX"></a>mPaint.setTextSkewX</h2><ol>
<li><p>方法：  </p>
<pre><code> void setTextSkewX (float skewX)  
</code></pre></li>
<li>作用:设置文本的斜切比(也叫文字的倾斜度),默认为 <strong>0</strong>，若要使用合适的倾斜文本，推荐使用 <strong>-0.25</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhrurhu6t3j207w08fmx6.jpg" alt="">  </li>
</ol>
<h2 id="mPaint-setTypeface"><a href="#mPaint-setTypeface" class="headerlink" title="mPaint.setTypeface"></a>mPaint.setTypeface</h2><ol>
<li><p>方法:  </p>
<pre><code> Typeface setTypeface (Typeface typeface)  
</code></pre></li>
<li>作用:设置文本的字体，传入 <strong>null</strong> 清除字体。<strong>Typeface</strong> 包含了字体的类型，粗细，还有倾斜、颜色等。    </li>
</ol>
<h2 id="mPaint-setUnderlineText"><a href="#mPaint-setUnderlineText" class="headerlink" title="mPaint.setUnderlineText"></a>mPaint.setUnderlineText</h2><ol>
<li><p>方法：  </p>
<pre><code> void setUnderlineText (boolean underlineText)  
</code></pre></li>
<li>作用:设置下划线<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhrutchzj3j207k08a746.jpg" alt="">  </li>
</ol>
<h1 id="getxx及其他方法"><a href="#getxx及其他方法" class="headerlink" title="getxx及其他方法"></a>getxx及其他方法</h1><h2 id="mpaint-getFontSpace"><a href="#mpaint-getFontSpace" class="headerlink" title="mpaint.getFontSpace"></a>mpaint.getFontSpace</h2><ol>
<li><p>方法:  </p>
<pre><code> float getFontSpacing () 
</code></pre><p>作用：返回基于当前文字大小和字体所推荐的一个行间距。在绘制多行文本的时候可以通过此方法更改文字的下一基线位置,使得两行文本之间的间距达到一个合适的值。  </p>
</li>
<li><p>例子:  </p>
<pre><code> String text = &quot;使用 drawText() 来绘制文字&quot;;
 canvas.drawText(text, 50, 100, paint);
 canvas.drawText(text, 50, 100 + paint.getFontSpacing(), paint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fi1xf7fkm2j20bv084dg3.jpg" alt="">  </p>
</li>
</ol>
<h2 id="mpaint-getFontMetric"><a href="#mpaint-getFontMetric" class="headerlink" title="mpaint.getFontMetric"></a>mpaint.getFontMetric</h2><ol>
<li><p>方法1:  </p>
<pre><code> Paint.FontMetrics getFontMetrics ()  
</code></pre></li>
<li><p>方法2：  </p>
<pre><code> float getFontMetrics (Paint.FontMetrics metrics)  
</code></pre></li>
<li>详解:<strong>FontMetricsInt</strong>共有 <strong>5</strong> 个值，分别是 <strong>top、bottom、ascent、descent、leading</strong><br><strong>top</strong> 与 <strong>bottom</strong> 限制了文字绘制的最大和最小的范围。<strong>ascent</strong> 和 <strong>descent</strong> 限制了字形的所有顶部与底部的范围（不同的字形有高低，有的顶高一些，有的底低一些),<strong>leading</strong> 表示两行文字各自的基线之间的间距<br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fi21sj2fd2j20oe06jwg6.jpg" alt=""><br>此图来源于扔物线大佬的杰作。<br>由图中按顺序，分别时 <strong>top、ascent、baseline、 descent、bottom</strong> 所在的直线。<br>并且以 <strong>baseline</strong> 为轴，在其上的线所在位置为负数距离，在其下的线所在的位置为正数距离。<br>例如:<code>fontMetric.bottom-fonMetric.top</code>即表示文字上下区域的一个最大高度。<br>另外，如果需要多次调用方法 <strong>1</strong>，那么可以选择使用方法 <strong>2</strong> 以提高性能。<br>注意:如果要使绘制的多个文本 <strong>baseline</strong> 对齐，可以使用<strong>int middle = (top + bottom) / 2;</strong><br>计算法来控制文本同在一条基线上。  </li>
</ol>
<h2 id="paint-getTextBound"><a href="#paint-getTextBound" class="headerlink" title="paint.getTextBound"></a>paint.getTextBound</h2><ol>
<li><p>方法1:  </p>
<pre><code> void getTextBounds (String text, int start, int end, Rect bounds)  
</code></pre></li>
<li><p>方法2:  </p>
<pre><code> void getTextBounds (char[] text,  int index, int count, Rect bounds)  
</code></pre></li>
<li>作用：返回文字四周的显示范围 </li>
<li>参数 <strong>bound</strong> 为一个矩形对象。当方法完成测量后会将值返回给该对象，进而得到一个矩形范围。如果矩形的四个坐标再加上一定偏移值则刚好可以将文字包围住。  </li>
<li><p>例子:  </p>
<pre><code> String text = &quot;绘制文字&quot;;
 paint.setStyle(Paint.Style.FILL);
 int offsetX = 50, offsetY = 100;
 canvas.drawText(text, offsetX, offsetY, paint);
 Rect bounds = new Rect();
 paint.getTextBounds(text, 0, text.length(), bounds);
 bounds.left += offsetX;
 bounds.top += offsetY;
 bounds.right += offsetX;
 bounds.bottom += offsetY;
 paint.setStyle(Paint.Style.STROKE);
 canvas.drawRect(bounds, paint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fi1yr1tk1gj208b059glg.jpg" alt=""><br><strong>注意</strong>：此方法测量出来的值会比 <strong>measureText()</strong> 更少一些，原因在于 <strong>measuresText</strong> 方法测量的是文字所占用的宽度，而者宽度还包括类文字两边默认的一个间隙。</p>
</li>
</ol>
<h2 id="mPaint-setXfermode"><a href="#mPaint-setXfermode" class="headerlink" title="mPaint.setXfermode"></a>mPaint.setXfermode</h2><ol>
<li><p>方法:  </p>
<pre><code> Xfermode setXfermode (Xfermode xfermode)  
</code></pre><p>作用：设置图像混合模式，其实是使用 <strong>Xfermode</strong>的子类 <strong>PorterDuffXfermode</strong>,而整个子类又是由 <strong>PorterDuff.Mode</strong>来决定的。</p>
</li>
</ol>
<h2 id="PorterDuff-Mode的详解"><a href="#PorterDuff-Mode的详解" class="headerlink" title="PorterDuff.Mode的详解"></a>PorterDuff.Mode的详解</h2><ol>
<li>名称由来：该种图像组合模式时由分别叫 <strong>Porter</strong> 和 <strong>Duff</strong> 两人提出的，因此为了表示对他们的敬意，便以二人的名称合体来命名这种模式。其实他们仅提出了12种<a href="https://en.wikipedia.org/wiki/Alpha_compositing" target="_blank" rel="noopener">Alpha合成模式</a>，后来为了方便便将图像混合的模式也加入到该类中。  </li>
<li>作用:用于图形合成时图像的饱和度、颜色值等的图像表现。</li>
<li>关键的两个图像:原图像(<strong>Source image</strong>)和目标图像(<strong>Destination image</strong>)  </li>
<li>两大模式:    </li>
</ol>
<ul>
<li>图像混合模式<br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhrw6t4vjwj20l50dzdg2.jpg" alt="">  </li>
<li>Alpha合成模式<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhrw5o0q33j20le0homxm.jpg" alt=""> </li>
</ul>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/15/一起看画布Canvas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="洪荣宣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ww1.sinaimg.cn/large/8992ce25gy1fengvigdatj205k05k0t0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rongxuanhong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/15/一起看画布Canvas/" itemprop="url">一起看画布Canvas</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-15T23:39:49+08:00">2017-07-15</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/15/一起看画布Canvas/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments:</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/15/一起看画布Canvas/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p><strong>版权声明：本文为博主原创文章，未经博主允许不得转载</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Canvas</code> 本意是画布的意思,然而将它理解为绘制工具一点也不为过。通过 <code>Canvas</code> 提供的  <strong>API</strong>，你可以在画布上绘制出绝大部分图形，再配合上一些操作画布的 <strong>API</strong>，比如旋转剪裁等变换画布的操作，就能够巧妙地画出更加复杂的图形。</p>
<h1 id="drawXXX系列"><a href="#drawXXX系列" class="headerlink" title="drawXXX系列"></a>drawXXX系列</h1><h2 id="canvas-drawArc"><a href="#canvas-drawArc" class="headerlink" title="canvas.drawArc"></a>canvas.drawArc</h2><ol>
<li><p>方法:  </p>
<pre><code> drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter,Paint paint)
 drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)
</code></pre></li>
<li>画的方向为顺时针</li>
<li><p>对参数的解释:</p>
<ul>
<li><strong>userCenter</strong> 若为true表示此弧会和 <code>RectF</code> 中心相连形成扇形，否则，弧的两头直接相连形成图形。</li>
<li><strong>startAngle</strong>，负数或大于360则对360模除。</li>
<li><strong>sweepAngle</strong>，大于360，则画出一圈。</li>
<li>角度：以 <code>RectF</code> 中心为坐标中心，中心所在直线为水平线，负角度弧斜上走，正角度弧斜下走,或者说以时钟三点钟为0度，顺时针为正，逆时针为负。  </li>
</ul>
</li>
<li><p>例子:  </p>
<pre><code> mPaint.setAntiAlias(true);
 mPaint.setColor(Color.RED);
 RectF mRecF=new RectF(20,20,200,200);
 canvas.drawArc(mRecF,-45,135,true,mPaint);//以斜上45度为起点，顺时针扫过135度
</code></pre></li>
</ol>
<ul>
<li><strong>useCenter</strong>=true<br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhkdaxydxnj208a09tglg.jpg" alt="">  </li>
<li><strong>useCenter</strong>=false<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkddhax22j208g09z0sl.jpg" alt=""></li>
</ul>
<h2 id="canvas-drawCircle"><a href="#canvas-drawCircle" class="headerlink" title="canvas.drawCircle"></a>canvas.drawCircle</h2><ol>
<li><p>方法:  </p>
<pre><code> drawCircle(float cx, float cy, float radius, Paint paint) 
</code></pre></li>
<li>对参数的解释:<ul>
<li><strong>cx,cy</strong> 为所画圆的中心坐标，<strong>radius</strong> 为圆的半径  </li>
</ul>
</li>
<li><p>例子  </p>
<pre><code> mPaint.setAntiAlias(true);
 mPaint.setColor(Color.RED);
 canvas.drawCircle(100,100,80,mPaint);   
</code></pre></li>
</ol>
<ul>
<li>圆心为（100，100），半径为80<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkdl5zl3xj208k08va9x.jpg" alt="">  </li>
</ul>
<ol>
<li><strong>注意：</strong> 当画笔设置了 <code>StrokeWidth</code> 时，圆的半径=内圆的半径+<code>StrokeWidth</code>/2  </li>
</ol>
<h2 id="canvas-drawBitmap"><a href="#canvas-drawBitmap" class="headerlink" title="canvas.drawBitmap"></a>canvas.drawBitmap</h2><ol>
<li><p>方法1: </p>
<pre><code> drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) 
</code></pre><p>对参数的解释:</p>
<ul>
<li><strong>bitmap</strong>:要画在画布上的位图</li>
<li><strong>matrix</strong>：构建的矩阵作用于将要画出的位图  </li>
</ul>
</li>
<li><p>方法2：</p>
<pre><code> drawBitmap(Bitmap bitmap, Rect src, RectF dst, Paint paint)
</code></pre><p>对参数的解释:</p>
<ul>
<li><strong>src</strong>:可为 <code>null</code>，表示画整个位图，否则只花出位图的一块矩形区域图.<strong>subset of bitmap</strong></li>
<li><strong>dst</strong>:定义的一个矩形范围，位图会平移或缩放来将自身放入矩形内  </li>
</ul>
</li>
<li><p>方法3:  </p>
<pre><code> drawBitmap(Bitmap bitmap, float left, float top, Paint paint)  
</code></pre></li>
<li><p>方法4： </p>
<pre><code> drawBitmapMesh(Bitmap bitmap, int meshWidth, int meshHeight, float[] verts, int vertOffset, int[] colors, int colorOffset, Paint paint) 
</code></pre><p>网格扭曲，水波等的绘制<br>知识：<a href="https://www.zybuluo.com/cxm-2016/note/506317" target="_blank" rel="noopener">https://www.zybuluo.com/cxm-2016/note/506317</a>  </p>
</li>
<li><p>例子:</p>
<ul>
<li><p>方法1:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  Matrix matrix = new Matrix();
  matrix.postTranslate(100,0);//左移100
  matrix.postRotate(45);//顺时针旋转45度
  canvas.drawBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher),matrix,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhkdykl9raj208c08gglj.jpg" alt="">  </p>
</li>
<li><p>方法2：  </p>
<pre><code>  Rect src = new Rect(20, 20, 40, 40);//取bitmap上src区域的部分图像
  Rect dst = new Rect(100, 100, 200, 200);//绘制的最终区域，一定填满
  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  canvas.drawBitmap(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher),src,dst,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhkemsmvrmj208n0943yc.jpg" alt="">  </p>
</li>
<li><p>方法3：  </p>
<pre><code>   canvas.drawBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher), 100, 100, mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkiibu7bej208r091a9x.jpg" alt="">  </p>
</li>
</ul>
</li>
</ol>
<h2 id="canvas-drawColor-drawRGB"><a href="#canvas-drawColor-drawRGB" class="headerlink" title="canvas.drawColor,drawRGB"></a>canvas.drawColor,drawRGB</h2><ol>
<li><p>方法：  </p>
<pre><code> drawColor(int color, PorterDuff.Mode mode) 
</code></pre><p>画整个画布的背景,但若区域受到剪裁，则只绘制剪裁区域的背景. 关键类 <code>PorterDuff.Mode</code>  </p>
</li>
<li>方法：<code>drawRGB(int r, int g, int b)</code><br>同上</li>
</ol>
<h2 id="canvas-drawLine-s"><a href="#canvas-drawLine-s" class="headerlink" title="canvas.drawLine(s)"></a>canvas.drawLine(s)</h2><ol>
<li><p>方法1： </p>
<pre><code> drawLine(float startX, float startY, float stopX, float stopY, Paint paint)
</code></pre><p>对参数的解释:</p>
<ul>
<li>前四个参数为直线的起点和终点的 <strong>XY</strong> 轴坐标  </li>
</ul>
</li>
<li><p>方法2：  </p>
<pre><code> drawLines(float[] pts,Paint paint)
</code></pre></li>
<li><p>方法3：</p>
<pre><code> drawLines(float[] pts, int offset, int count, Paint paint)  
</code></pre><p>对参数的解释：</p>
<ul>
<li><strong>pts</strong>:待画的坐标点数组，格式为(<strong>x1,y1,x2,y2,…</strong>),至少4个值</li>
<li><strong>offset</strong>:要跳过坐标点数组中几个值才开始画(必须是4的倍数)</li>
<li><strong>count</strong>:至少为2，<strong>offset</strong> 之后数组的大小。  </li>
</ul>
</li>
<li><p>例子  </p>
<ul>
<li><p>方法1:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(16);
  canvas.drawText(&quot;起点(20,100)&quot;, 22, 100, mPaint);
  canvas.drawText(&quot;终点(50,100)&quot;, 52, 150, mPaint);
  canvas.drawLine(20, 100, 50, 150, mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkhqxwiugj209u0a5q2u.jpg" alt="">  </p>
</li>
<li><p>方法2：  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(16);
  canvas.drawText(&quot;A1(20,100)&quot;, 0, 90, mPaint);
  canvas.drawText(&quot;A2(100,350)&quot;, 40, 370, mPaint);
  canvas.drawText(&quot;B1(100,100)&quot;, 80, 90, mPaint);
  canvas.drawText(&quot;B2(180,350)&quot;, 150, 370, mPaint);
  float[] points=new float[]{20,100,100,350,100,350,100,100,100,100,180,350};//至少4个值，即能够绘制一条直线
  canvas.drawLines(points,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhki2nfpkqj20930b9dfw.jpg" alt="">  </p>
</li>
<li><p>方法3:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(16);
  canvas.drawText(&quot;A1(100,350)&quot;, 40, 370, mPaint);
  canvas.drawText(&quot;B2(100,100)&quot;, 80, 90, mPaint);
  canvas.drawText(&quot;B3(180,350)&quot;, 150, 370, mPaint);
  float[] points=new float[]{20,100,100,350,100,350,100,100,100,100,180,350};//至少4个点
  canvas.drawLines(points,4,8,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhki5jfgn1j20950aqdft.jpg" alt="">  </p>
</li>
</ul>
</li>
</ol>
<h2 id="canvas-drawRect"><a href="#canvas-drawRect" class="headerlink" title="canvas.drawRect"></a>canvas.drawRect</h2><ol>
<li><p>方法1：</p>
<pre><code> void drawRect(float left, float top, float right, float bottom, Paint paint)  
</code></pre><p>确定矩形四个顶点的位置配上画笔即可  </p>
</li>
<li><p>方法2: </p>
<pre><code> void drawRect(Rect r, Paint paint) 
</code></pre><p>矩形的四个位置为整型时使用</p>
</li>
<li><p>方法3:  </p>
<pre><code> void drawRect(RectF r, Paint paint)  
</code></pre><p>方法1的另一简版，矩形的四个位置为浮点型时使用  </p>
</li>
<li><p>例子:  </p>
<pre><code> mPaint.setAntiAlias(true);
 mPaint.setColor(Color.RED);
 canvas.drawRect(new RectF(20f, 20f, 120f, 120f), mPaint);
 //canvas.drawRect(new Rect(20, 20, 120, 120), mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhknan9823j208m07gdfm.jpg" alt="">  </p>
</li>
</ol>
<h2 id="canvas-drawOval"><a href="#canvas-drawOval" class="headerlink" title="canvas.drawOval"></a>canvas.drawOval</h2><p>绘制椭圆<br>类似 <code>drawRect</code>  </p>
<h2 id="canvas-drawPaint"><a href="#canvas-drawPaint" class="headerlink" title="canvas.drawPaint"></a>canvas.drawPaint</h2><p>方法：<br>        <code>drawPaint(Paint paint)</code><br>自定义的 <code>paint</code> 画在整个画布上,等于用 <code>paint</code> 在画布上画一个无限大的矩形，但当前画布受到剪裁，则染色区域仅限于剪裁部分。</p>
<h2 id="canvas-drawPoint-s"><a href="#canvas-drawPoint-s" class="headerlink" title="canvas.drawPoint(s)"></a>canvas.drawPoint(s)</h2><p>绘制点，方法基本类似<code>drawLine(s)</code></p>
<h2 id="canvas-drawRoundRect"><a href="#canvas-drawRoundRect" class="headerlink" title="canvas.drawRoundRect"></a>canvas.drawRoundRect</h2><ol>
<li><p>方法1：  </p>
<pre><code> drawRoundRect(RectF rect, float rx, float ry, Paint paint)   
</code></pre></li>
<li><p>方法2: </p>
<pre><code> drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)  
</code></pre><p>对参数的解释：  </p>
<ul>
<li><strong>rx,ry</strong> 表示 <strong>left</strong> 到 <strong>left+rx</strong> 与 <strong>left</strong> 到 <strong>left+ry</strong> 所围区域做弧，其余三个角类似，当 <strong>rx=ry&gt;=(right-left)/2</strong> 时表示画一个半径为 <strong>rx(ry)</strong> 的圆（刚好外接一个矩形） </li>
</ul>
</li>
<li><p>例子  </p>
<ul>
<li><p>方法1:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  RectF mRecf = new RectF(20, 100, 200, 200);
  canvas.drawRoundRect(mRecf, 30, 50, mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhkir0hoogj208u08qweb.jpg" alt="">  </p>
</li>
<li>方法2:API level至少21，做法一样  </li>
</ul>
</li>
</ol>
<h2 id="canvas-drawText"><a href="#canvas-drawText" class="headerlink" title="canvas.drawText"></a>canvas.drawText</h2><ol>
<li><p>方法1: </p>
<pre><code> drawText(String text, float x, float y, Paint paint)  
</code></pre><p>在 <strong>x,y</strong> 位置开始画 <strong>text</strong><br><strong>注意</strong>：其中 <strong>y</strong> 表示文字的基线(<strong>baseline</strong> )所在的坐标,说白了就是我们小学写字用的那种带有横线的本子(一般都是按照一条基线来写字是吧？)，用于规范你写的字是否成一条直线，否则很多人写着写着就往上飘了。而 <strong>x</strong> 坐标就是文字绘制的起始水平坐标，但是每个文字本身两侧都有一定的间隙，故实际文字的位置会比 <strong>x</strong> 的位置再偏右侧一些。  </p>
</li>
<li>图:<br>基线类似下图深绿色的横线<br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fi1xvfruh0j205101iq30.jpg" alt="">  </li>
<li><p>方法2：</p>
<pre><code> drawText(CharSequence text, int start, int end, float x, float y, Paint paint)  
</code></pre><p>在 <strong>x,y</strong> 位置上画出 <strong>start</strong> 到 <strong>end</strong>(不含 <strong>end</strong>) 之间的字符  <strong>CharSequence charSequence = “charSequence”;</strong></p>
</li>
<li><p>方法3： </p>
<pre><code> drawText(char[] text, int index, int count, float x, float y, Paint paint)  
</code></pre><p>对参数的解释:</p>
<ul>
<li><strong>index</strong>:表示从第几个字符开始，</li>
<li><strong>count</strong>:表示截取的数组长度</li>
<li>字符数组的定义: <strong>char[] a=”abc”.toCharArray()</strong> </li>
</ul>
</li>
<li><p>方法4： </p>
<pre><code> drawTextOnPath(String text, Path path, float hOffset, float vOffset, Paint paint)
</code></pre><p>对参数的解释:</p>
<ul>
<li><strong>path</strong>:文本绘制的路径（关键）</li>
<li><strong>hOffset</strong>:相对于路径的水平偏移量</li>
<li><strong>vOffset</strong>:相对于路径的垂直偏移量  </li>
</ul>
</li>
<li><p>方法5：</p>
<pre><code> drawTextOnPath(char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)  
</code></pre><p> 方法3和4的合体  </p>
</li>
<li><p>方法6： </p>
<pre><code> drawTextRun(CharSequence text, int start, int end, int contextStart, int contextEnd, float x, float y, boolean isRtl, Paint paint)  
</code></pre><p>对参数的解释：  </p>
<ul>
<li><strong>contextStart</strong>:可选，直接=start</li>
<li><strong>contextEnd</strong>：可选，直接=end</li>
<li><strong>x,y</strong>：文字绘制起点</li>
<li><strong>isRt1(isRightToLeft)</strong>:文字是否支持<strong>rtl</strong></li>
<li><code>0 &lt;= contextStart &lt;= start &lt;= end &lt;= contextEnd &lt;= text.length</code>  </li>
</ul>
</li>
<li><p>方法7：  </p>
<pre><code> drawTextRun(char[] text, int index, int count, int contextIndex, int contextCount, float x, float y, boolean isRtl, Paint paint)  
</code></pre><p>方法3和方法6合体</p>
<p> <code>count = end - start, contextCount = contextEnd - contextStart.</code> </p>
</li>
<li><p>例子:</p>
<ul>
<li><p>方法1：  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(20);
  canvas.drawText(&quot;Canvas学习&quot;,50,100,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhkiz81vydj209808yglg.jpg" alt="">  </p>
</li>
<li><p>方法2:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(20);
  CharSequence charSequence=&quot;Canvas学习&quot;;
  canvas.drawText(charSequence,1,charSequence.length(),30,50,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhkj2jak50j20930a2dfo.jpg" alt="">  </p>
</li>
<li><p>方法3:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(20);
  char[] chars=&quot;Canvas学习&quot;.toCharArray();
  canvas.drawText(chars,1,chars.length-1,30,50,mPaint);  
</code></pre><p>效果图同方法2  </p>
</li>
<li><p>方法4：  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(20);
  Path path=new Path();
  String text=&quot;Canvas学习&quot;;
  path.addCircle(100,100,50, Path.Direction.CCW);
  canvas.drawTextOnPath(text,path,0f,0f,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkjb2a4jrj209109iwec.jpg" alt=""></p>
</li>
</ul>
</li>
</ol>
<h2 id="canvas-drawPath"><a href="#canvas-drawPath" class="headerlink" title="canvas.drawPath"></a>canvas.drawPath</h2><p>方法:<code>drawPath(Path path, Paint paint)</code><br>根据定义的路径画出图<br>例子:  </p>
<pre><code>        mPaint.setAntiAlias(true);
        mPaint.setColor(Color.RED);
        Path path=new Path();
        path.addCircle(100,100,50, Path.Direction.CCW);
        canvas.drawPath(path,mPaint);  
</code></pre><p>效果等于画一个圆   </p>
<h1 id="canvas-clipxxx系列"><a href="#canvas-clipxxx系列" class="headerlink" title="canvas.clipxxx系列"></a>canvas.clipxxx系列</h1><h2 id="canvas-clipPath"><a href="#canvas-clipPath" class="headerlink" title="canvas.clipPath"></a>canvas.clipPath</h2><ol>
<li><p>方法1：</p>
<pre><code> clipPath(Path path)  
</code></pre><p>按所定义的路线剪裁,默认Region.Op.INTERSECT表示剪裁出相交的部分</p>
</li>
<li><p>方法2：</p>
<pre><code> clipPath(Path path, Region.Op op)  
</code></pre><p>解释：用指定的路径 <strong>path</strong> 修改当前的剪裁<br>对op参数的理解:以剪裁两次的区域分别为A，B来区别</p>
<ul>
<li><strong>Region.Op.DIFFERENCE</strong>:剪裁出差异的部分，类似 <strong>A-B</strong> 部分</li>
<li><strong>Region.Op.REPLACE</strong>:后剪裁B的覆盖剪裁的A</li>
<li><strong>Region.Op.REVERSE_DEFFERENCE</strong>:剪裁出差异的部分，类似 <strong>B-A</strong> 部分</li>
<li><strong>Region.Op.INTERSECT</strong>:剪裁出相交的部分，类似 <strong>A交B</strong> 部分</li>
<li><strong>Region.Op.UNION</strong>:剪裁出AB合并的部分，类似<strong> AUB</strong></li>
<li><strong>Region.Op.XOR</strong>：是<strong> (AUB)-(A交B)</strong> 刚好与<strong> A交B</strong> 相对</li>
</ul>
</li>
<li><p>方法3：</p>
<pre><code> clipRect(Rect[F] rect, Region.Op op)[]表示可选  
</code></pre><p>解释：用指定的矩形来修改当前的剪裁  </p>
</li>
<li><p>方法4：</p>
<pre><code> clipRect(Rect rect)  
</code></pre><p>剪裁一个矩形区域，还有其他能构造矩形的方法不再列出  </p>
</li>
<li><p>例子(以剪裁路径为例):<br>首次剪裁  </p>
<pre><code>     Path path=new Path();
     path.addCircle(100,100,50, Path.Direction.CCW);
     canvas.clipPath(path);
     canvas.clipPath(path);
     canvas.drawColor(Color.RED);//红色区域即为剪裁的区域  
</code></pre><p>由于 <strong>clipPath</strong> 方法剪裁模式默认为<strong>Region.Op.INTERSECT</strong>，故当前剪裁部分和整个画布相交即为本身。<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkm5so2wxj2092091q2r.jpg" alt="">  </p>
</li>
<li><p>剪裁模式(绿色区域为最终得到的剪裁部分)  </p>
<pre><code> mPaint.setAntiAlias(true);
 mPaint.setColor(Color.RED);
 canvas.drawColor(Color.BLUE);
 canvas.drawRect(new RectF(20, 20, 120, 120), mPaint);
 canvas.drawCircle(120, 70, 50, mPaint);
 canvas.clipRect(new RectF(20, 20, 120, 120));
 Path path = new Path();
 path.addCircle(120, 70, 50, Path.Direction.CCW);
 canvas.clipPath(path, Region.Op.INTERSECT);
 canvas.drawColor(Color.GREEN);  
</code></pre></li>
</ol>
<ul>
<li><strong>Region.Op.INTERSECT</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkmtcumfzj208n09f0sk.jpg" alt="">  </li>
<li><strong>Region.Op.REPLACE</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkmunykaaj208f08gweb.jpg" alt="">  </li>
<li><strong>Region.Op.REVERSE_DEFFERENCE</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkmw0yqbrj208g08da9v.jpg" alt="">  </li>
<li><strong>Region.Op.UNION</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkmxdkq2aj208l08la9v.jpg" alt="">  </li>
<li><strong>Region.Op.XOR</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkmylwokrj208a07tt8j.jpg" alt=""></li>
</ul>
<h1 id="canvas的保存与恢复"><a href="#canvas的保存与恢复" class="headerlink" title="canvas的保存与恢复"></a>canvas的保存与恢复</h1><ol>
<li>解释：用来保存或恢复 <code>Canvas</code> 的状态  </li>
<li>作用：<code>save</code> 之后可以调用 <code>Canvas</code> 的平移、放缩、旋转、错切、裁剪等对当前画布进行操作,再进行相应的绘制，避免影响画布上已绘制的 <code>view</code>，配合 <code>canvas.restore()</code>(将当前画布恢复到初始状态) 使用  </li>
</ol>
<h1 id="canvas的变幻操作"><a href="#canvas的变幻操作" class="headerlink" title="canvas的变幻操作"></a>canvas的变幻操作</h1><h2 id="canvas-translate"><a href="#canvas-translate" class="headerlink" title="canvas.translate"></a>canvas.translate</h2><ol>
<li><p>方法: </p>
<pre><code> canvas.translate(float dx, float dy)  
</code></pre><p>作用：移动当前画布水平距离 <strong>dx</strong>，竖直距离 <strong>dy</strong>  </p>
</li>
<li><p>例子:  </p>
<pre><code> mPaint.setAntiAlias(true);
 mPaint.setColor(Color.RED);
 canvas.drawColor(Color.BLUE);
 canvas.translate(100,100);
 canvas.drawCircle(0,0,50,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhknou7kvmj2085086web.jpg" alt="">  </p>
<h2 id="canvas-scale"><a href="#canvas-scale" class="headerlink" title="canvas.scale"></a>canvas.scale</h2></li>
<li><p>方法1: </p>
<pre><code> canvas.scale(float sx, float sy)  
</code></pre><p>作用：<strong>sx、sy</strong> 是 <strong>x、y</strong> 方向上缩放的倍数,画布缩放后，再画出的图片相应的坐标都会进行缩放  </p>
</li>
<li><p>例子:  </p>
<pre><code> mPaint.setAntiAlias(true);
 mPaint.setColor(Color.RED);
 canvas.drawColor(Color.BLUE);
 canvas.save();
 canvas.scale(0.5f,0.5f);//x,y均缩小一半
 canvas.drawCircle(100,100,50,mPaint);
 canvas.restore();
 mPaint.setColor(Color.WHITE);
 canvas.drawCircle(100,100,50,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkns0kgnjj208k081mx0.jpg" alt="">  </p>
</li>
<li><p>方法2: </p>
<pre><code> canvas.scale (float sx, float sy, float px, float py)  
</code></pre><p>作用:缩放画布并平移画布到基准点<strong>(px,py) </strong><br>对参数的解释:  </p>
<ul>
<li><strong>px,py</strong> 为缩放后画布新的坐标原点(也叫缩放基准点)  </li>
</ul>
</li>
<li><p>例子:  </p>
<pre><code> mPaint.setAntiAlias(true);
 canvas.drawColor(Color.BLUE);
 mPaint.setColor(Color.WHITE);
 canvas.drawCircle(100,100,50,mPaint);
 canvas.save();
 canvas.scale(0.5f,0.5f,100,100);
 mPaint.setColor(Color.RED);
 canvas.drawCircle(100,100,50,mPaint);
 canvas.restore();  
</code></pre></li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhknuznikij209408nq2s.jpg" alt=""></p>
<h2 id="canvas-rotate"><a href="#canvas-rotate" class="headerlink" title="canvas.rotate"></a>canvas.rotate</h2><ol>
<li><p>方法： </p>
<pre><code> canvas.rotate(float degrees)  
</code></pre><p>作用：顺时针旋转当前画布一定角度，也可加入基准点坐标  </p>
</li>
<li><p>例子：  </p>
<pre><code> mPaint.setAntiAlias(true);
 canvas.drawColor(Color.BLUE);
 mPaint.setColor(Color.WHITE);
 canvas.drawRect(new RectF(80,80,180,180),mPaint);
 canvas.save();
 canvas.rotate(45);
 //canvas.rotate(45,200,200);
 mPaint.setColor(Color.RED);
 canvas.drawRect(new RectF(80,80,180,180),mPaint);
 canvas.restore();  
</code></pre></li>
</ol>
<ul>
<li><p>无基准点  </p>
<p>  <img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhko1i33kfj208p09gweb.jpg" alt="">  </p>
</li>
<li><p>有基准点 (200，200)  </p>
<p>  <img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhko2cl6xaj208u094mx0.jpg" alt="">  </p>
<h2 id="canvas-skew"><a href="#canvas-skew" class="headerlink" title="canvas.skew"></a>canvas.skew</h2></li>
</ul>
<ol>
<li><p>方法: </p>
<pre><code> canvas.skew(float sx, float sy)  
</code></pre><p>作用:画布的错切</p>
</li>
</ol>
<ul>
<li><strong>sx</strong>:将画布在 <strong>x</strong> 方向上倾斜相应的角度，<strong>sx</strong> 为倾斜角度的 <strong>tan</strong> 值；</li>
<li><strong>sy</strong>:将画布在 <strong>y</strong> 轴方向上倾斜相应的角度，<strong>sy</strong> 为倾斜角度的 <strong>tan</strong> 值；<br>比如在 <strong>X</strong> 轴方向上倾斜45度，<strong>tan45=1</strong>;  </li>
</ul>
<ol>
<li><p>例子:  </p>
<pre><code> mPaint.setAntiAlias(true);
 canvas.drawColor(Color.BLUE);
 mPaint.setColor(Color.WHITE);
 canvas.drawRect(new RectF(0,0,180,180),mPaint);
 canvas.save();
 canvas.skew(1,0);//画布X轴倾斜45度
 mPaint.setColor(Color.RED);
 canvas.drawRect(new RectF(0,0,180,180),mPaint);
 canvas.restore();  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkpi1m3d6j209907xa9x.jpg" alt=""></p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上大致介绍了 <strong>Canvas</strong> 类中众多绘制方法。首先，先对方法进行解析；其次，给出相应的示例代码并结合运行效果，旨在帮助读者更好地理解诸如上述绘制方法的基本使用；最后，对于方法的理解如有纰漏，欢迎指正。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p><a href="https://developer.android.google.cn/reference/android/graphics/Canvas.html" target="_blank" rel="noopener">官方Canvas类API</a><br><a href="http://blog.csdn.net/tianjian4592/article/details/45234419" target="_blank" rel="noopener">Canvas之translate、scale、rotate、skew方法讲解</a></p>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/Java代理模式与Android的情结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="洪荣宣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ww1.sinaimg.cn/large/8992ce25gy1fengvigdatj205k05k0t0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rongxuanhong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/15/Java代理模式与Android的情结/" itemprop="url">Java代理模式与Android的情结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-15T20:45:12+08:00">2017-05-15</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/15/Java代理模式与Android的情结/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments:</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/05/15/Java代理模式与Android的情结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p><strong>版权声明：本文为博主原创文章，未经博主允许不得转载</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Java</code> 代理模式在 <code>Android</code> 中有很多的应用。比如 <code>Android</code> 中 <code>Binder</code> 的 <code>Client</code> 部分就是通过代理模式来访问 <code>Server</code> 端的、代理 <code>Activity</code> 或 <code>Fragment</code> 模式、还有很多开源框架也都使用了代理模式 (<strong>主要是动态代理</strong>)。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>简单地说</strong>，代理模式就是代理对象为其他真实对象 (<strong>也叫被代理对象</strong>) 提供代理机制，以便控制对真实对象的访问。此时，如果真实对象不想直接和客户端接触，则可让代理对象充当真实对象与客户端之间的中介来联系二者，完成事务联系。<br><strong>抽象地说</strong>，代理对象和被代理对象一般实现相同的接口，调用者与代理对象进行交互。代理的存在对于调用者来说是透明的，调用者看到的只是接口。代理对象则可以封装一些内部的处理逻辑，如访问控制、远程通信、日志、缓存等。比如一个对象访问代理就可以在普通的访问机制之上添加缓存的支持</p>
<p>举个简单的例子，比如中国移动 (<strong>真实对象</strong>) 和用户 (<strong>客户端</strong>) 之间的这种业务关系。首先，我们老百姓不可能直接和中国移动总部接触，因而中国移动会将业务的操作权下放到各个省市乡的代理点       ( <strong>代理对象</strong>),而用户到代理店办的业务其实就是总部的业务，这样一来便可大大地扩大业务，也能更方便服务用户。  </p>
<h1 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h1><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1ffmdhtgsm3j20c706tmx3.jpg" alt=""><br><strong>UML解析：</strong>首先,定义了一个 <code>Subject</code> 类型的接口，并声明了接口方法 <code>DoAction()</code>;其次，分别定义了两个实现了 <code>Subject</code> 接口的代理类 <code>Proxy</code> 以及 真实对象类 <code>RealSubject</code> ,其中代理类代表了(<code>delegate</code>)真实对象类；最后，客户端 <code>Cient</code> 依赖关联 <code>Subject</code>,再由 <code>Subject</code> 操作 <code>DoAction()</code>。  </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>public interface Subject {
//做操作
void doAction();
}

public class RealSubject implements Subject{

@Override
public void doAction() {

}
}  

public class Proxy implements Subject {
private RealSubject mRealSubject=null;
private void preDoAction(){
    //do something before doAction
}
@Override
public void doAction() {
   if (mRealSubject==null)
       mRealSubject=new RealSubject();
    preDoAction();//代理类准备事情
    //代理类与真实对象类搞事情了，等于代理类执行了真实类中对应的那个方法了，
    //即代理类隐藏了真实类中方法的实现细节。
    mRealSubject.doAction();
    postDoAction();//代理类善后
}
private void postDoAction(){
    //do something after doAction
}
 }  


public class Client {
public static void main(String[] args) throws Throwable {
    Subject subject=new Proxy();
    subject.doAction();//代理类代替真实类做事情
}
}
</code></pre><p>以上就是静态代理的代码实现。你可以看见，每个代理类都需要一个真实类来对应，即代理类依赖于真实类的对象。</p>
<h3 id="静态代理如何用"><a href="#静态代理如何用" class="headerlink" title="静态代理如何用"></a>静态代理如何用</h3><p>我先举个场景。我们需要拿到数据,而数据分别来源于本地、内存及网络，定义一个方法 <code>getData()</code> 用于获取数据。由于我们数据有三种，我们必然需要分别实现 <code>getData()</code>,此时，我们将此方法抽取到接口中，三个实现类各自实现接口即可。然而，现在我们需要在每次获取数据前后执行一些公共操作，比如缓存，日志处理等。那么，最差的做法就是每个实现类都去实现一样的逻辑后再去调用。而如果我们利用静态代理，就可以将此方法代理出去。在代理方法中完整的执行获取数据及其公共操作部分，而隐藏 <code>getData()</code><br>的实现细节，实现细节交由各个实现类处理。这样一来，调用者只需调用这个代理方法，而无需和其他实现类交互。在代码层面，客户端调用获取数据的方法时代码调用趋于固定，而如果以后需要修改 <code>getData()</code>  实现细节，也只需要改动实现类中对应的方法即可，这样便提高了可扩展性。</p>
<blockquote>
<p>注：getData()类似上述Subject中的doAction(),代理方法类似Proxy中的doAction()</p>
</blockquote>
<p>然而，当每个代理类都对应一个真实类，那么大量使用的话会引起代码量的急剧膨胀，因而我们就需要一种机制—不需要提前知道真实类，而是在动态运行中才指定这样一个类。那么这样就引入了代理模式的另一种方式—动态代理。  </p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="涉及到的几个类"><a href="#涉及到的几个类" class="headerlink" title="涉及到的几个类"></a>涉及到的几个类</h3><ol>
<li><strong>接口</strong> <code>InvocationHandler</code>：该接口中仅定义了一个方法 <code>Object：invoke(Object obj,Method method, Object[] args)</code>。在实际使用时，第一个参数 <code>obj</code> 一般是指代理类，<code>method</code> 是被代理的方法，如上例中的 <code>doAction()</code>，<code>args</code> 为该方法的参数对象数组。这个抽象方法在代理类中动态实现<strong>(反射调用)</strong>。  </li>
<li><strong>Proxy</strong>：该类即为生成的动态代理类的父类，作用类似于静态代理中的 <code>Proxy</code>，其中主要包含以下内容：<ul>
<li>构造函数 <code>Protected Proxy(InvocationHandler h)</code>，其中子类 (<strong>生成的动态代理类</strong>)继承父类构造方法可获得 <strong>h</strong> 实例 。  </li>
<li><code>Static Class getProxyClass (ClassLoaderloader, Class[] interfaces)</code>：获得一个代理类，其中 <strong>loader</strong> 是类装载器引用，<strong>interfaces</strong> 是被代理类所拥有的全部接口的数组。</li>
<li><code>Static Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)</code>：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在 <code>Subject</code> 接口中声明过的方法),也就是此时代理类已获得被代理类的类似功能，故你只需操作代理类完成所需请求即可。  </li>
</ul>
</li>
</ol>
<h3 id="机制分析"><a href="#机制分析" class="headerlink" title="机制分析"></a>机制分析</h3><p>动态代理允许客户端在运行时刻动态地创建出实现了多个接口的代理类及其对象。其中每一个代理类的对象都会关联一个表示内部处理逻辑的接口类 <code>InvocationHandler</code> (<strong>继承父类含参构造方法可得到接口引用</strong>)实现。当客户端调用了代理对象所代理的接口方法时，信息会被 <code>InvocationHandler</code> 中的 <code>invoke()</code> 方法拦截处理。在 <code>invoke()</code> 方法里可以截取到代理类的对象，代理方法对应的 <code>Method</code> 对象以及实际调用的参数,然后再经过处理而后返回新的对象。</p>
<p>接下来我们来看看代码实现。  </p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p><code>Subject</code> 以及 <code>RealSubject</code> 同上  </p>
<ol>
<li><p><strong>实现了调用处理器监听的动态代理类</strong>   </p>
<pre><code> public class DynamicProxyObject implements InvocationHandler {
 private Object mObject;//被代理对象的引用

 public DynamicProxyObject(Object object) {
     mObject = object;
 }

 @Override
 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
     System.out.println(&quot;before calling &quot; + method);
     Object object=method.invoke(mObject,args);
     System.out.println(&quot;after calling &quot; + method);
     return object;
 }
 }
</code></pre></li>
<li><p><strong>客户端类</strong>   </p>
<pre><code> public class Client {
 public static void main(String[] args) throws Throwable {
     RealSubject rs = new RealSubject();
     InvocationHandler handler = new DynamicProxyObject(rs);
     Class cl = rs.getClass();
     //第一种.分解步骤得到代理类对象
     //Class c = Proxy.getProxyClass(cl.getClassLoader(), cl.getInterfaces());
     //Constructor ct = c.getConstructor(new Class[]{InvocationHandler.class});
     //Subject subject1 = (Subject) ct.newInstance(new Object[]{handler});
    //第二种.一次性得到代理类对象
     Subject subject=
     (Subject) Proxy.newProxyInstance(cl.getClassLoader(),cl.getInterfaces(),handler);
      subject.doAction();
 }
 }
</code></pre></li>
<li><p><strong>总结</strong>  </p>
<p> 通过这种方式，被代理的对象(<code>RealSubject</code>)可以在运行时动态改变，需要控制的接口(<code>Subject</code> 接口)可以在运行时改变，控制的方式(<code>DynamicProxyObject</code> 类)也可以动态改变，从而实现了非常灵活的动态代理机制。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>主要以 <code>Proxy</code> 类为主 (<code>该类位于java.lang.reflect 包下</code>)</p>
<h2 id="几个重要的静态变量"><a href="#几个重要的静态变量" class="headerlink" title="几个重要的静态变量"></a>几个重要的静态变量</h2><pre><code> private final static String proxyClassNamePrefix = &quot;$Proxy&quot;;

 //动态代理类的构造函数参数类数组
 private final static Class[] constructorParams ={ InvocationHandler.class };

 //映射表：用于维护类加载器对象到其对应的代理类缓存
 private static Map&lt;ClassLoader, Map&lt;List&lt;String&gt;, Object&gt;&gt; loaderToCache
         = new WeakHashMap&lt;&gt;();

 //标记动态代理类正在创建中
 private static Object pendingGenerationMarker = new Object();

 //用于创建唯一的动态代理类名而定义的 number，可递增
 private static long nextUniqueNumber = 0;
 private static Object nextUniqueNumberLock = new Object();

 //同步表：记录所有已创建的动态代理类实例类型，可供 isProxyClass() 使用
 private static Map&lt;Class&lt;?&gt;, Void&gt; proxyClasses =
         Collections.synchronizedMap(new WeakHashMap&lt;Class&lt;?&gt;, Void&gt;());

 //动态代理类关联的 InvocationHandler
 protected InvocationHandler h;  
</code></pre><h2 id="获取动态代理类实例的方法1"><a href="#获取动态代理类实例的方法1" class="headerlink" title="获取动态代理类实例的方法1"></a>获取动态代理类实例的方法1</h2><pre><code> private static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) 
 throws IllegalArgumentException
 { 
  Class&lt;?&gt; proxyClass = null;

 //收集接口名用来作为代理类缓存的key
 String[] interfaceNames = new String[interfaces.length];

 //用于检测重复接口名
 Set&lt;Class&lt;?&gt;&gt; interfaceSet = new HashSet&lt;&gt;();

 for (int i = 0; i &lt; interfaces.length; i++) {
     //验证class loader 解析出来的接口是否与反射出来的类对象相同
     String interfaceName = interfaces[i].getName();
     Class&lt;?&gt; interfaceClass = null;
     try {
         //Java反射得到一个类对象
         interfaceClass = Class.forName(interfaceName, false, loader);
     } catch (ClassNotFoundException e) {
     }
     //当前反射得到的类对象不等于接口数组中的接口类对象
     if (interfaceClass != interfaces[i]) {
         throw new IllegalArgumentException(
                 interfaces[i] + &quot; is not visible from class loader&quot;);
     }

     //验证反射出来的类对象是否是接口
     if (!interfaceClass.isInterface()) {
         throw new IllegalArgumentException(
                 interfaceClass.getName() + &quot; is not an interface&quot;);
     }

     //验证接口类对象不重复
     if (interfaceSet.contains(interfaceClass)) {
         throw new IllegalArgumentException(
                 &quot;repeated interface: &quot; + interfaceClass.getName());
     }
     //每次反射得到的类对象即接口对象存入 Set 集合
     interfaceSet.add(interfaceClass);
     //数组记录接口类名
     interfaceNames[i] = interfaceName;
 }

 //接口名数组转接口名集合,以作为代理类缓存的 key
 List&lt;String&gt; key = Arrays.asList(interfaceNames);

 //为类加载实例查找或者创建代理类缓存
 Map&lt;List&lt;String&gt;, Object&gt; cache;
 synchronized (loaderToCache) {
     cache = loaderToCache.get(loader);
     if (cache == null) {//无则创建加入缓存映射表
         cache = new HashMap&lt;&gt;();
         loaderToCache.put(loader, cache);
     }
 }
 //接下来就是使用 key 检索代理类缓存。而这次检索将会产生以下三张情况
 //1.空值 null. 意味着当前类加载器中没有该代理类
 //2.正在创建的对象.意味着一个代理类正在创建中.
 //3.类对象的一个弱引用,意味着代理类此时已经创建.

 synchronized (cache) {
     do {
         Object value = cache.get(key);
         if (value instanceof Reference) {
             proxyClass = (Class&lt;?&gt;) ((Reference) value).get();
         }
         if (proxyClass != null) {
             //上述情况3，直接返回代理类实例
             return proxyClass;
         } else if (value == pendingGenerationMarker) {
             // 上述情况2，需要等待创建成功
             try {
                 cache.wait();
             } catch (InterruptedException e) {

             }
             continue;
         } else {

             //上述情况1，标记正在创建.
             cache.put(key, pendingGenerationMarker);
             break;
         }
     } while (true);
 }

 try {
     String proxyPkg = null;     //定义代理类所在的包名

     //记录非公有代理类接口的包名以便代理类都能被定义在相同包名下,
     // 并验证所有的非公有代理类接口都在相同包名下.
     for (int i = 0; i &lt; interfaces.length; i++) {
         int flags = interfaces[i].getModifiers();
         if (!Modifier.isPublic(flags)) {//是否公有
             String name = interfaces[i].getName();
             int n = name.lastIndexOf(&#39;.&#39;);
             String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));
             if (proxyPkg == null) {//接口名作为包名
                 proxyPkg = pkg;
             } else if (!pkg.equals(proxyPkg)) {//包名不同
                 throw new IllegalArgumentException(
                         &quot;non-public interfaces from different packages&quot;);
             }
         }
     }

     if (proxyPkg == null) {
         proxyPkg = &quot;&quot;;
     }
      //直接生成代理类引用
     {
         //得到所有接口的方法对象集合
         List&lt;Method&gt; methods = getMethods(interfaces);
         //方法对象集合排序
         Collections.sort(methods, ORDER_BY_SIGNATURE_AND_SUBTYPE);
         //验证每个方法的返回类型
         validateReturnTypes(methods);
         //去掉重复的方法，并收集异常
         List&lt;Class&lt;?&gt;[]&gt; exceptions = deduplicateAndGetExceptions(methods);

         Method[] methodsArray = methods.toArray(new Method[methods.size()]);
         Class&lt;?&gt;[][] exceptionsArray =
         exceptions.toArray(new Class&lt;?&gt;[exceptions.size()][]);

         //定义动态代理类的名字 proxyName
         final long num;
         synchronized (nextUniqueNumberLock) {
             num = nextUniqueNumber++;
         }
         String proxyName = proxyPkg + proxyClassNamePrefix + num;
         //利用 generateProxy() 方法传入所需参数得到动态代理类的引用
         proxyClass = generateProxy(proxyName, interfaces, loader, methodsArray,
                 exceptionsArray);
     }
     //保存数据
     proxyClasses.put(proxyClass, null);

 } finally {

     //异常进入处理，如果代理类创建成功则用弱引用处理后加入代理类缓存中，
     // 否则去除该key所对应的正在创键的代理类
     synchronized (cache) {
         if (proxyClass != null) {
             cache.put(key, new WeakReference&lt;Class&lt;?&gt;&gt;(proxyClass));
         } else {
             cache.remove(key);
         }
         //刷新缓存集合
         cache.notifyAll();
     }
 }
 return proxyClass;
 }
</code></pre><h2 id="动态创建代理类实例的方法2"><a href="#动态创建代理类实例的方法2" class="headerlink" title="动态创建代理类实例的方法2"></a>动态创建代理类实例的方法2</h2><pre><code>  public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,
 InvocationHandler h) throws IllegalArgumentException
 {
  if (h == null) {
     throw new NullPointerException();
 }
 Class&lt;?&gt; cl = getProxyClass(loader, interfaces);

 /*
  * @param constructorParams 构造器参数类数组
  * 利用构造器反射得到关联了 InvocationHandler 的代理类实例
  *
  */
 try {
     final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
     return newInstance(cons, h);//实际调用了  cons.newInstance(new Object[] {h} );
 } catch (NoSuchMethodException e) {
     throw new InternalError(e.toString());
 }
    }  
</code></pre><h2 id="动态创建出实现了接口方法的代理类代码例子"><a href="#动态创建出实现了接口方法的代理类代码例子" class="headerlink" title="动态创建出实现了接口方法的代理类代码例子"></a>动态创建出实现了接口方法的代理类代码例子</h2><pre><code> import com.example.hrx.mvpdemo.bean.Subject;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.lang.reflect.UndeclaredThrowableException;

 public final class DynamicProxyType extends Proxy implements Subject {
 private static Method m1;
 private static Method m0;
 private static Method m3;
 private static Method m2;

 //构造方法，参数就是一开始实例化的InvocationHandler接口的实例 继承自 Proxy
 public $Proxy1(InvocationHandler var1){
     super(var1);
 }

 public final boolean equals(Object var1){
     try {
         return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
     } catch (RuntimeException | Error var3) {
         throw var3;
     } catch (Throwable var4) {
         throw new UndeclaredThrowableException(var4);
     }
 }

 public final int hashCode() {
     try {
         return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
     } catch (RuntimeException | Error var2) {
         throw var2;
     } catch (Throwable var3) {
         throw new UndeclaredThrowableException(var3);
     }
 }
 //动态代理类代理的方法实现
 public final void doAction()  {
     try {
         super.h.invoke(this, m3, (Object[])null);
     } catch (RuntimeException | Error var2) {
         throw var2;
     } catch (Throwable var3) {
         throw new UndeclaredThrowableException(var3);
     }
 }

 public final String toString()  {
     try {
         return (String)super.h.invoke(this, m2, (Object[])null);
     } catch (RuntimeException | Error var2) {
         throw var2;
     } catch (Throwable var3) {
         throw new UndeclaredThrowableException(var3);
     }
 }

 //static代码块加载Method对象
 static {
     try {
         m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[]{Class.forName(&quot;java.lang.Object&quot;)});
         m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);
         m3 = Class.forName(&quot;com.example.hrx.Subject&quot;).getMethod(&quot;doAction&quot;, new Class[0]);
         m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);
     } catch (NoSuchMethodException var2) {
         throw new NoSuchMethodError(var2.getMessage());
     } catch (ClassNotFoundException var3) {
         throw new NoClassDefFoundError(var3.getMessage());
     }
 }
 }
</code></pre><h3 id="动态代理怎么用"><a href="#动态代理怎么用" class="headerlink" title="动态代理怎么用"></a>动态代理怎么用</h3><p>我们仍以静态代理怎么用中的场景为例。当实现类越来越多时，利用动态代理，能够大大简化代码量。而我们在静态代理的代理方法实现类似地被放在了动态代理中invoke()中，但是实现形式有差异。后者主要利用反射来拿到所需要的实现类的被代理方法，其他则和静态代理无异。</p>
<h1 id="与-Android-的情结"><a href="#与-Android-的情结" class="headerlink" title="与 Android 的情结"></a>与 Android 的情结</h1><h2 id="Retrofit-中自定义的网络请求到-OkHttp-Call-的适配"><a href="#Retrofit-中自定义的网络请求到-OkHttp-Call-的适配" class="headerlink" title="Retrofit 中自定义的网络请求到 OkHttp.Call 的适配"></a>Retrofit 中自定义的网络请求到 OkHttp.Call 的适配</h2><p>我们都知道可以使用类似 <code>GitHub github = retrofit.create(GitHub.class)</code> 来获得接口的引用；其实在内部是创建了一个实现了我们自定义的接口 <code>GitHub</code> 的动态代理类，当我们开始执行网络请求时，代理类会按照 <code>Retrofit</code> 先前配置的逻辑来处理我们发出的网络请求：比如交由 <code>okhttp3.Call</code> 来进行网络请求。<code>Retrofit</code> 完成的是封装客户网络请求的高效工作，而真正的网络请求的工作是委托给了 <code>OkHttp</code> 来完成。  </p>
</li>
</ol>
<p><strong>关键代码:</strong></p>
<pre><code>    public final class Retrofit {

      public &lt;T&gt; T create(final Class&lt;T&gt; service) {
        //此处同样应用上述创建动态代理类实例方法
        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] 
        { service },new InvocationHandler() {
              private final Platform platform = Platform.get();
               @Override
               public Object invoke(Object proxy, Method method, Object... args)
                  throws Throwable {
                // method来自Object.class则不做自定义处理
                if (method.getDeclaringClass() == Object.class) {
                  return method.invoke(this, args);
                }
                //默认处理，即根据平台类型（Android、Java8、IOS）做处理
                if (platform.isDefaultMethod(method)) {
                  return platform.invokeDefaultMethod(method, service, proxy, args);
                }
                ServiceMethod serviceMethod = loadServiceMethod(method);
                OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
                return serviceMethod.callAdapter.adapt(okHttpCall);
              }
            });
      }
    }  
</code></pre><h2 id="binder机制"><a href="#binder机制" class="headerlink" title="binder机制"></a>binder机制</h2><p>在跨进程通信中，<code>binder</code> 作为通信的媒介，联系了客户端 <code>Client</code> 与服务端 <code>Server</code> 的信息交流。<br>接下来，我们来看一张图：<br><img src="http://images2015.cnblogs.com/blog/13430/201705/13430-20170516223354650-984999229.png" alt=""><br>注：图中 <strong>SM</strong> 表示 <code>ServerManager</code>，其在 <code>Android</code> 中是联系这四大组件的关键。  </p>
<p>首先,<code>Server</code> 必须先注册到 <strong>SM</strong> 中，才能够有机会和 <code>Client</code> 通信，然后 <code>Client</code> 发起请求想要调用 <code>Server</code> 中的方法 <code>add()</code>，然而 <code>Client</code> 与 <code>Server</code> 处在不同的进程当中。如果没有媒介<code>binder</code> 驱动的帮助，进程间就无法完成通信。因此，透过 <code>binder</code> 的作用，<code>Server</code> 可以给 <code>Client</code> 下发一个代理对象，以便能够调用 <code>Server</code>中的方法。这样以来，<code>Client</code> 就无法知道 <code>Server</code> 的逻辑，而只能调用被 <code>Server</code> 代理出去的方法 <code>add()</code>。这一通信过程，便是跨进程通信。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Java</code> 代理模式的应用还是相当广泛的。对于静态代理模式，我们可以用它来代理 <code>Activity</code> 或者 <code>Fragment</code> 的生命周期方法，定义一个不注册的 <code>ActivityDelegate</code> 或者   <code>FragmentDelegate</code>,这个可能会是比较特别的高级技巧。对于动态代理，涉及到的大多是第三方框架，其中思想很多包含有动态代理。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p><a href="http://blog.csdn.net/liangbinny/article/details/18656791" target="_blank" rel="noopener">Java设计模式之代理模式(Proxy)</a><br><a href="http://blog.csdn.net/jianghuxiaoxiami/article/details/3403924" target="_blank" rel="noopener">JAVA 代理模式（Proxy）</a><br><a href="http://coderbao.com/2016/06/04/ProxyPattern&amp;DynamicProxyInJava/" target="_blank" rel="noopener">代理模式和Java中的动态代理机制</a><br><a href="http://blog.csdn.net/jspandasp/article/details/72511465" target="_blank" rel="noopener">写给Android App开发人员看的Android底层知识</a></p>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/13/Hexo与Disqus引入的故事/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="洪荣宣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ww1.sinaimg.cn/large/8992ce25gy1fengvigdatj205k05k0t0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rongxuanhong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/13/Hexo与Disqus引入的故事/" itemprop="url">Hexo与Disqus引入的故事</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-13T16:37:35+08:00">2017-05-13</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/13/Hexo与Disqus引入的故事/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments:</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/05/13/Hexo与Disqus引入的故事/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p><strong>版权声明：本文为博主原创文章，未经博主允许不得转载</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 是一个支持向各个网络平台提供留言服务的公司，属于美国本土的公司。但由于国内目前不支持访问，故 Disqus 评论框的显示必须翻墙方可显示，这也是其中的一个局限。  </p>
<hr>
<h1 id="注册-Disqus"><a href="#注册-Disqus" class="headerlink" title="注册 Disqus"></a>注册 Disqus</h1><p>注册方式有多种，支持 google 帐号、facebook、twitter 等第三方帐号登录，选择一种即可。  </p>
<h1 id="添加-disqus-到-网址"><a href="#添加-disqus-到-网址" class="headerlink" title="添加 disqus 到 网址"></a>添加 disqus 到 网址</h1><ol>
<li>首先，前往个人中心选择 add disqus to site<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1ffjsfbpxs7j204s08omx3.jpg" alt="">  </li>
<li>其次，进入新页面下滑至底部，点击 GET STARTED<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1ffjsi1qfukj20ao06tq2x.jpg" alt="">  </li>
<li>然后，选择 I want to install Disqus on my site  </li>
<li>到了创建阶段，填好你的 website name（<strong>很重要，后面有用,可以取名字缩写</strong>），选好其他选项，点击 create site<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1ffjskuswudj20hl0hb0tc.jpg" alt="">  <h1 id="最后-Disqus-的配置"><a href="#最后-Disqus-的配置" class="headerlink" title="最后 Disqus 的配置"></a>最后 Disqus 的配置</h1>可直接跳到第二步选择支持平台或者其他平台按操作添加相关代码。但如果你的网站是Hexo 平台(已集成 Disqus),则无需选择平台了,可直接调到第三步完成配置。</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1ffjsuls2svj207z089weg.jpg" alt=""><br>第三步配置 disqus,仅需把你要添加评论的网址填入 Website URL 即可，最后完成创建，完毕。<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1ffjszk07q3j20l90eut91.jpg" alt="">  </p>
<h1 id="Hexo里的配置"><a href="#Hexo里的配置" class="headerlink" title="Hexo里的配置"></a>Hexo里的配置</h1><ul>
<li>以 next 主题为例，首先到 Hexo 下的 theme 中找到主题配置文件:<strong>_config.yml</strong>,再定位至 <strong>disqus</strong> 字段，开启 enable，并填入你之前在 Disqus 官网填入的 Website Name 到 disqus 字段下的<strong>shortname</strong> 处。  </li>
<li>执行<strong>hexo clean,hexo g,hexo d</strong>，更新部署新的样式到远程。至此故事结束。  </li>
</ul>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/01/巧用设计模式实现Recyclerview各种复杂Item类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="洪荣宣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ww1.sinaimg.cn/large/8992ce25gy1fengvigdatj205k05k0t0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rongxuanhong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/01/巧用设计模式实现Recyclerview各种复杂Item类型/" itemprop="url">巧用设计模式实现Recyclerview各种复杂Item类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-01T21:05:50+08:00">2017-05-01</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/01/巧用设计模式实现Recyclerview各种复杂Item类型/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments:</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/05/01/巧用设计模式实现Recyclerview各种复杂Item类型/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p><strong>版权声明：本文为博主原创文章，未经博主允许不得转载</strong></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  在实际项目的开发中，首页的布局基本上都是复杂的 UI，而我们的实现思路一般就是利用 <code>RecyclerView</code> 结合 <code>getItemType()</code>，并在适配器里根据不同的 <code>item</code> 类型去创建不同的 <code>ViewHolder</code>,最后在 <code>onBindViewHolder()</code> 中依然是根据 <code>item</code> 类型来绑定对应的数据。这种方法是最基本的方法，相信大家都懂。但是，其缺点也很明显，就是可扩展性太差。</p>
<p> 接下来，我将介绍另一种更为巧妙的方法来实现，以期大大提高其扩展性。我们将以 <code>item</code> 的布局 <code>id</code> 作为区别<code>item</code>的唯一标志并结合两种设计模式,为大家呈现一种新颖，简洁的方式来实现此类复杂布局。其中如有纰漏，望请悉心指出。  </p>
<h1 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h1><p>本实现方法主要用到了 <code>Java</code> 设计模式中的访问者模式和工厂方法模式，亦涉及到 <code>ViewHolder</code> 的封装技巧。  </p>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><ol>
<li><p><strong>概念</strong><br><code>Java</code> 中的访问者模式属于一种行为型设计模式，核心主要由访问者与被访问者两部分组成。一般对于同一场景来说，被访问者都是由不同类的类型所表示，而不同的访问者可以对被访问者进行不同的访问操作。其中，被访问者常利用集合结构来存储(比如 <code>List</code> )，访问者通过遍历集合实现对其中存储的元素的逐个操作。  </p>
</li>
<li><p><strong>UML类图</strong></p>
</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1ff5p96ef3lj20dw0e53yz.jpg" alt="访问者模式UML类图"> </p>
<blockquote>
<p>出处:<a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">维基百科</a>  </p>
</blockquote>
<p><strong>UML解读</strong></p>
<p>   该<code>UML</code>类图中有两个类：访问者(<code>Visitor</code>)和被访问者(<code>Element</code>),然后有多个具体访问者继承访问者 <code>Visitor</code>（eg: <code>ConcreateVisitor1</code> ），也有多个具体被访问者继承被访问者 <code>Element</code>（eg: <code>ConcreateElementA</code> ） 。首先，<code>Visitor</code> 中为每个具体被访问者定义了一个可访问具体被访问者操作的方法(通过注入具体被访问者的引用)；其次，<code>Element</code> 中定义了一个接受访问的方法 <code>accept</code>，并且依赖注入访问者 <code>visitor</code>，以便访问者可以访问被访问者；然后，<code>Object Structure</code> 对象结构主要用于存储被访问者。因此，对于每个被访问者都应先从该对象结构中取出来。最后，客户端 <code>Client</code> 定义集合对象收集被访问者数据，通过对集合的遍历完成访问者对每一个被访问元素的访问操作。  </p>
<blockquote>
<p>具体例子详见推荐博客 <a href="http://blog.csdn.net/janice0529/article/details/41151987" target="_blank" rel="noopener">Java设计模式之 访问者模式【Visitor Pattern】</a>  </p>
</blockquote>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><ol>
<li><p><strong>概念</strong>  </p>
<p> 工厂方法模式是一种实现了“工厂”概念的面向对象设计模式 ,是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”</p>
</li>
<li><p><strong>UML类图</strong></p>
<p> <img src="http://ww1.sinaimg.cn/large/8992ce25gy1ff5uwck661j209p05qdfq.jpg" alt="工厂模式"></p>
<blockquote>
<p>出处:<a href="https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科</a>  </p>
</blockquote>
</li>
</ol>
<p><strong>UML解读</strong>  </p>
<p>   首先在创建器 <code>Creator</code> 中定义一个工厂方法用于生产未指定具体类型的产品，其次，子类—具体创建器 <code>ConcreteCreator</code> 实现父类工厂方法，给出创建具体产品类型的实现，最后，客户端只需调用具体创建者中的方法即可得到所需的产品。  </p>
<blockquote>
<p>具体例子详见推荐博客<a href="http://blog.csdn.net/zhengzhb/article/details/7348707" target="_blank" rel="noopener">工厂方法模式</a></p>
</blockquote>
<h1 id="BaseViewHolder的封装"><a href="#BaseViewHolder的封装" class="headerlink" title="BaseViewHolder的封装"></a>BaseViewHolder的封装</h1><pre><code>/**
 * 封装的 viewholder 用于获取各个 item 上的控件 采用集合存储取过的控件
 */

public  class BaseViewHolder extends RecyclerView.ViewHolder {
protected View itemView;//每个item的布局视图view
protected SparseArray&lt;View&gt; list;//itemView上所有控件的集合

public BaseViewHolder(View itemView) {
    super(itemView);
    this.itemView = itemView;
    list=new SparseArray&lt;&gt;();
}
/**
*获取 itemView 上控件
*/
 public &lt;T&gt; T getView(int id) {
    View view = list.get(id);
    if (view == null) {
        view = itemView.findViewById(id);
        list.put(id, view);
    }
    return (T) view;
}
</code></pre><p><code>BaseViewHolder</code> 继承至 <code>RecyclerView.ViewHolder</code> ，可作为 <code>Recyclerview</code> 适配器中通用的 <code>ViewHolder</code> 来使用，因此你无需在每个适配器里面再定义内部类 <code>MyViewHolder</code>。<code>BaseViewHolder</code> 可以在构造器中获取到每个 <code>item</code> 的 <code>itemView</code>，然后就可以定义一个快速获取 <code>itemView</code> 上各个子控件的方法 <code>getView</code>,以后在适配器中获取 <code>item</code> 子控件能够随时调用此方法.  </p>
<h1 id="BetterViewHolder"><a href="#BetterViewHolder" class="headerlink" title="BetterViewHolder"></a>BetterViewHolder</h1><pre><code>public abstract class BetterViewHolder&lt;T&gt; extends BaseViewHolder {
public BetterViewHolder(View itemView) {
    super(itemView);
}

/**
 * 绑定 item 的数据
 * @param t 每个item的实体引用
 */
public abstract void bindDataToItem(T t,int position);
}  
</code></pre><p><code>BetterViewHolder</code> 声明为抽象类型，在 <code>BaseViewHolder</code> 基础上再次封装了一层。主要定义了一个抽象方法用于实现适配器中 <code>onBindViewHolder（T t，int position)</code> 的功能。但由于子类的实体类型不可确定，故需要借助泛型技巧,定义T来表示子类的泛型。因此，子类只需继承该类，并指定子类所需的实体类型即可。  </p>
<h1 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h1><ul>
<li><p>本例中定义了四种 <code>item</code> 布局类型,如下图所示  </p>
<p>  <img src="http://ww1.sinaimg.cn/large/8992ce25gy1fjdetu2ltuj20fd0i7gmf.jpg" alt=""></p>
</li>
</ul>
<p><strong>布局代码见底部源码</strong>  </p>
<ul>
<li>定义访问者 <code>TypeFactory</code>   </li>
</ul>
<pre><code>    public abstract class TypeFactory {  

    public abstract int type(Banner banner);

    public abstract int type(Category category);

    public abstract int type(Item item);

    public abstract int type(Footer footer);
    //工厂方法模式应用 
    public  abstract BetterViewHolder onCreateViewHolder(View itemView,int  type);
    }
</code></pre><ul>
<li>定义被访问者 <code>Visitable</code></li>
</ul>
<pre><code>    /*
    *定义抽象的被访问者 type方法，用来接收/引用一个抽象访问者对象,以便利用这个对象进行操作;
    */
    public abstract class Visitable {
    public abstract int type(TypeFactory factory);
    }  
</code></pre><ul>
<li><p>定义四个实体类并继承<code>Visitable</code>  </p>
<pre><code>  /**
    * Created by hrx on 2017/4/30.
   * 具体的被访问者
    * 实现type抽象方法，通过传入的具体访问者参数、
    * 调用具体访问者对该对象的访问操作方法实现访问逻辑;
   * 比如这就是利用抽象访问者 TypeFactory 引用来调用操作方法获取对应该 Banner 关联的布局  id
   */

  public class Banner extends Visitable{
       @Override
      public int type(TypeFactory factory) {
       return factory.type(this);
      }
   }  

  public class Category extends Visitable {
    @Override
    public int type(TypeFactory factory) {
       return factory.type(this);
    }
  }  
  public class Item extends Visitable {
      private int position;
      @Override
      public int type(TypeFactory factory) {
          return factory.type(this);
      }

      public int getPosition() {
          return position;
      }

      public void setPosition(int position) {
          this.position = position;
      }
  }
  public class Footer extends Visitable {
    @Override
     public int type(TypeFactory factory) {
        return factory.type(this);
        }
   }  
</code></pre></li>
<li><p>具体访问者 <code>TypeFactoryList</code>   </p>
<pre><code>  /*
   * 具体的访问者实现了抽象访问者的方法
  * 同时 onCreateViewHolder 也是利用工厂方法模式创建了各个 item 的 viewholder 实例
  */

  public class TypeFactoryList extends TypeFactory {
  //声明每个item的布局id
  public static final int BANNER = R.layout.banner;
  public static final int CATEGORY = R.layout.category;
  public static final int ITEM = R.layout.item;
  public static final int FOOTER = R.layout.footer;

  @Override
  public int type(Banner banner) {
      return BANNER;
  }

  @Override
  public int type(Category category) {
      return CATEGORY;
  }

  @Override
  public int type(Item item) {
      return ITEM;
  }

  @Override
  public int type(Footer footer) {
      return FOOTER;
  }

  @Override
  public BetterViewHolder onCreateViewHolder(View itemView, int type) {
      BetterViewHolder viewHolder = null;
      switch (type) {
          case BANNER:
              viewHolder = new BannerViewHolder(itemView);
              break;
          case CATEGORY:
              viewHolder = new CategoryViewHolder(itemView);
              break;
          case ITEM:
              viewHolder = new ItemViewHolder(itemView);
              break;
          case FOOTER:
              viewHolder = new FooterViewHolder(itemView);
              break;
          default:
              break;
      }
      return viewHolder;
   }
  }  
</code></pre></li>
<li><p>定义适配器   </p>
<pre><code>  public class MainActivityAdapter extends RecyclerView.Adapter&lt;BetterViewHolder&gt; {
  private List&lt;Visitable&gt; mVisitables;
  private TypeFactory factory;

  public MainActivityAdapter(List&lt;Visitable&gt; mVisitables) {
      this.mVisitables = mVisitables;
      factory = new TypeFactoryList();
  }
  //此 ViewHolder 的创建细节已经抽象到 TypeFactoryList 中去实现了 此处等同与获取工厂生产的产品
  @Override
  public BetterViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
      View itemView = View.inflate(parent.getContext(), viewType, null);
      return factory.onCreateViewHolder(itemView, viewType);
  }

  //此处的实现交由 BetterViewHolder 的各个子类去实现，故此处 Java 会根据相应的子类去获取其下实现的 bindDataToItem（）,利用JAVA动态分派而无需进行类型检查
  @Override
  public void onBindViewHolder(BetterViewHolder holder, int position) {
      holder.bindDataToItem(mVisitables.get(position),position);
  }

  //此处即代表访问者模式中的客户端调用被访问者的 type()，进行访问操作获取其布局 id
  @Override
  public int getItemViewType(int position) {
      return mVisitables.get(position).type(factory);
  }
  @Override
  public int getItemCount() {
      return mVisitables.size();
  }
  }  
</code></pre><p>该适配器的数据就是得到访问者模式中的对象结构 <code>Object Structure</code> 中存储的被访问者集合，对应到例子中就是 <code>mVisitables</code> 集合。同时需要一个访问者引用,以便该适配器(客户端)能够利用这个引用获取每个被访问者关联到的布局Id(利用该引用执行某些操作)，如<code>mVisitables.ge(position).type(factory)</code>可以获取到每个被访问者关联到的布局 <code>id</code>。  </p>
</li>
<li><p>四个 <code>BetterViewHolder</code> 的子类  </p>
<p>  四个子类代表了其对应 <code>item</code> 的 <code>ViewHolder</code> ,可以在该类上实现 <code>item</code> 上的操作，比如点击事件，设置 <code>item</code> 上子控件的所有数据等。  </p>
</li>
</ul>
<p><strong>代码见底部源码</strong>  </p>
<ul>
<li><code>Activity</code> 收集数据并设置适配器  </li>
</ul>
<pre><code>    public class MainActivity extends AppCompatActivity {

    private RecyclerView recyclerView;
    private List&lt;Visitable&gt; mVisitable;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        recyclerView = (RecyclerView) findViewById(R.id.recyclerview);
        //默认4列
        final GridLayoutManager manager = new GridLayoutManager(this, 4);
        //此方法定义每个item占几列,有点类似线性布局的权重属性
        manager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {
            @Override
            public int getSpanSize(int position) {
                if (position &gt; 2 &amp;&amp; position &lt; 7) {
                    return 1;
                }
                return 4;
            }
        });
        recyclerView.setLayoutManager(manager);
        initData();
        recyclerView.setAdapter(new MainActivityAdapter(mVisitable));

    }

    private void initData() {
        mVisitable = new ArrayList&lt;&gt;();
        //按布局的顺序依次加入各个被访问者
        Banner banner = new Banner();
        mVisitable.add(banner);
        Category category = new Category();
        mVisitable.add(category);
        //加入4个item
        for (int i = 0; i &lt; 5; i++) {
            Item item = new Item();
            item.setPosition(i + 2);
            mVisitable.add(item);
        }
        Footer footer = new Footer();
        mVisitable.add(footer);
    }
}
</code></pre><blockquote>
<p>注:<code>mVisitable</code> 集合中被访问者的加入顺序即代表了最终显示出来的顺序，并且集合中的每个元素仅能代表其中一个 <code>item</code>，意味着如果你要重复该 <code>item</code> 就要重复声明一个实体再加入集合中。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用访问者模式和工厂方法模式大大解耦了上述复杂布局的实现过程，同时可扩展性大大提高。如果往后还需修改布局，只需修改对应 <code>item</code> 的布局文件和数据的绑定。而若是增加 <code>item</code>，那么只需定义新的实体加入被访问者集合中，同时编写布局文件及对应的 <code>ViewHolder</code> 实现即可。这样一来，不同 <code>item</code> 间就不会相互影响，变得易维护和易扩展，相信你学会之后，一定会爱上此法。  </p>
<p>最后，谢谢你看到这里，欢迎交流意见。   </p>
<p><a href="https://github.com/rongxuanhong/MultiItemLayout" target="_blank" rel="noopener">源码地址</a></p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p><a href="http://www.jianshu.com/p/c6a44e18badb" target="_blank" rel="noopener">[译]关于 Android Adapter，你的实现方式可能一直都有问题</a><br><a href="http://blog.csdn.net/janice0529/article/details/41151987" target="_blank" rel="noopener">Java设计模式之 访问者模式【Visitor Pattern】</a><br><a href="http://blog.csdn.net/zhengzhb/article/details/7348707" target="_blank" rel="noopener">Java设计模式之 工厂方法模式</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://ww1.sinaimg.cn/large/8992ce25gy1fengvigdatj205k05k0t0.jpg"
                alt="洪荣宣" />
            
              <p class="site-author-name" itemprop="name">洪荣宣</p>
              <p class="site-description motion-element" itemprop="description">Rongxuanhong's Blog</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/rongxuanhong" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:francishongrx@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.jianshu.com/u/68e7b05458bc" target="_blank" title="简书"><i class="fa fa-fw fa-globe"></i>简书</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://blog.csdn.net/u013534680" target="_blank" title="CSDN"><i class="fa fa-fw fa-globe"></i>CSDN</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">洪荣宣</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="Total Visitors">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="Total Views">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.6"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.6"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.6"></script>



  



	





  





  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'PHg2RRIUgmj5CjX5xB2yjkbQ-gzGzoHsz',
        appKey: '3feashi2HbnYMycDoEQPqaIx',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    
  


  
  

  

  

  

  

  <!-- 页面点击小红心 start--> 
  <script type="text/javascript" src="/js/src/love.js"></script>
<!-- 页面点击小红心 end--> 

<!--崩溃欺骗-->
<script>
var OriginTitile = document.title;
 var titleTime;
 document.addEventListener('visibilitychange', function () {
     if (document.hidden) {
        // $('[rel="icon"]').attr('href', "/img/TEP.ico");
         document.title = '╭(°A°`)╮ 页面崩溃啦 ~ ';
         clearTimeout(titleTime);
     }
     else {
       //  $('[rel="icon"]').attr('href', "/favicon.ico");
         document.title = '(ฅ>ω<*ฅ) 噫又好了~' + OriginTitile;
         titleTime = setTimeout(function () {
             document.title = OriginTitile;
         }, 2000);
     }
 });
 </script>
</body>
</html>
