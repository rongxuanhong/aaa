<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">









  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.6" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.6">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.6" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.6',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Rongxuanhong&apos;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Rongxuanhong&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="Rongxuanhong&#39;s Blog">
<meta property="og:description" content="Rongxuanhong&apos;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rongxuanhong&#39;s Blog">
<meta name="twitter:description" content="Rongxuanhong&apos;s Blog">






  <link rel="canonical" href="http://yoursite.com/page/13/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Rongxuanhong's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rongxuanhong's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">脚踏实地地做好自己</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
</li>

      

      
    </ul>
  

  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/20/python中闭包与装饰器解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="洪荣宣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ww1.sinaimg.cn/large/8992ce25gy1fengvigdatj205k05k0t0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rongxuanhong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/20/python中闭包与装饰器解析/" itemprop="url">python中闭包与装饰器解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-20T11:09:41+08:00">2018-03-20</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/20/python中闭包与装饰器解析/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments:</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/03/20/python中闭包与装饰器解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开启本文的内容介绍时，我们先来了解下什么是函数式编程。所谓的函数式编程其实是一种编程范式，用人话就是写代码所遵循的一种方法或模式。简单地说，当某个函数(可称高阶函数)可以接受函数对象当做输入参数和返回值，这样一种写法即函数式编程。那么本文的闭包则应用了函数式编程的思想，而装饰器可以说是闭包的应用之一。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是程序运行时变量可被访问的范围，故有全局变量和局部变量之说。一般我们把定义在函数之外的变量称之为全局变量，其作用域为当前文件或者当前类下。而定义在函数体内的局部变量称之为局部变量。而在python中函数可以嵌套，因而作用域的范围也有了明显的层级关系。即作用域最外层&gt;第一层函数&gt;第二层函数&gt;…第n层函数,有相对的访问限制。我们来看个例子。  </p>
<p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fpayu1fudij20u104daa7.jpg" alt=""></p>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>我们先从一个例子来看看。  </p>
<p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fpaznm1msmj20u503q74d.jpg" alt="">  </p>
<p>这段代码最终的输出结果是<code>python</code>。按照一般的生命周期，变量<code>name</code>会随着<code>function()</code>的调用而移出内存。然而当你利用<code>function()</code>的返回函数<code>wrapper</code>再次调用时，仍旧返回了变量<code>name</code>的值，那也就说它并没有离开内存。这其实就是闭包的作用，它使得局部变量在函数外被访问成为可能。<br>而在<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">Wiki</a>)上，闭包的定义如下:在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。</p>
<p>在定义中的关键信息就是自由变量和函数(具体所指见上图),简单地说，该自由变量和函数一同存在于一个封闭的环境即函数所在的作用域内，同生共死。  </p>
<p>总之，闭包本质上是一个函数，它包括了自由变量和函数两大部分，闭包使得这些变量的值保存在内存中。</p>
<h2 id="闭包中的难点"><a href="#闭包中的难点" class="headerlink" title="闭包中的难点"></a>闭包中的难点</h2><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fpb7mq94kkj20u805lt8p.jpg" alt=""> </p>
<p>首先可以自己先想一下如果是你，你会给出什么样的答案??  如果是 <strong>0,2,4,6</strong> 那么请往下看。</p>
<p>首先我们定义了一个函数 <code>fun()</code>  并且是以列表生成式的方式返回结果，并且列表中的元素是由匿名函数lambda定义的。<br>为什么答案都是 <code>6</code> 呢？其实这是由于闭包的后期绑定导致的late binding,意思就是说在闭包中的自由变量是在内部函数被调用时被查找的，而随着 <code>for</code> 循环的执行，<code>i</code> 的值已经被更新到了<strong>3</strong>，即在闭包的封闭环境中自由变量 <code>i</code> 每次被查找都是拿到<code>3</code>的结果,再乘以 <code>2</code>，自然每次结果只能都是 <code>6</code> 。<br>那如果不想得到这样的结果，如何改写？ 下面提供两种优雅的写法。  </p>
<p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fpb84qewo6j20u3060dfz.jpg" alt=""></p>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="简单的装饰器"><a href="#简单的装饰器" class="headerlink" title="简单的装饰器"></a>简单的装饰器</h2><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fpb0bx66boj20u805xt9d.jpg" alt="">  </p>
<p><code>decorator</code> 就代表了一个装饰器，它用于给 <code>log</code> 函数增加额外的功能。实际的装饰过程定义在嵌套函数内部，在函数内部，<code>log</code>函数对象 以 <code>func</code> 参数来表示。那么这样一看就好像<code>log</code>被<code>decorator</code> 装饰了一样。</p>
<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>在<code>python</code>,能在代码运行期间动态增加功能的方式即借助<code>@</code>符号。而这和<code>Java</code> 中的注解差不多一个意思。那么我们就可以用它来简化装饰器的调用过程。  </p>
<p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fpb0x1xv3hj20u005t0t9.jpg" alt="">  </p>
<p>如上所示，<code>@</code>语法自动帮我们调用了<code>decorator(log)</code>,省去了一次手动调用的过程，现在只需要调用一次<code>log()</code>,即可得到装饰效果，可谓是便民操作。而且如果还有其他函数也想被该装饰器装饰，同样加上个<code>@decorator</code>即可。这样其实也有一种封装代码的思想在里面。</p>
<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>装饰器本质上亦是函数，那么就会有传入参数的需求。比如根据<code>level</code> 级别做不同的装饰操作,如此依赖也提高了装饰器的扩展性。</p>
<p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fpb5qb8lspj20tz08o3yz.jpg" alt="">  </p>
<p>如上所示，我们给装饰器函数<code>user_logging</code>设置了一个参数，这样当你指定不同的<code>level</code> 时，<code>log</code> 就会输出不同的结果。在此程序中调用<code>log(&quot;hrx&quot;)</code> 等价于调用<code>wrapper=user_logging(decorator(log))</code> ,然后再调用<code>wrapper(&quot;hrx&quot;)</code>，这样其实比前述例子多了一层函数调用(因为多嵌套了一个函数)。  </p>
<blockquote>
<p>注：我们使用*arg,**kw作为 wrapper 函数的参数，这样设置之后表示此函数可以接受任意位置参数和关键字参数，这样一来 log 函数就可以指定各种各样的参数。  </p>
</blockquote>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>函数有装饰器，其实类也有装饰器，思想一样，但写法不太一样。其中实现装饰的步骤主要在类中的<code>__call__ ()</code> 方法中进行。<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fpb6bwaarlj20u00ap0t1.jpg" alt="">  </p>
<h2 id="装饰器的缺点"><a href="#装饰器的缺点" class="headerlink" title="装饰器的缺点"></a>装饰器的缺点</h2><p>在以上例子中，装饰器的实质都是<code>log=wrapper</code> (表面调用的是<code>log</code> ，但实际上调用了<code>wrapper</code> 执行),所以如果此时输入<code>log.__name__</code>得到的将会是<code>wrapper</code>的名字。可以使用<code>wrapper__name__=log__name__</code>,或利用<code>python</code> 内置装饰器<code>functiontools.wrap</code>实现。<code>wrap</code>操作可以将原函数的元信息拷贝到装饰器函数中的<code>func</code>内。<strong>所以完整的装饰器函数还应该加上<code>functiontools.wrap(func)</code></strong>。  </p>
<p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fpb75si22kj20u20bwgmg.jpg" alt="">  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>记住,<code>python</code> 中一切皆为对象,而函数算个特殊的对象吧。在闭包中，主要由函数对象与自由变量，加上其所处的封闭环境组成。再来，利用闭包，又得到了装饰器的用法，最后既扩展的函数的功能，又方便了代码的编写。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://gohom.win/2015/10/25/pyDecorator/" target="_blank" rel="noopener">Python装饰器和符号@</a><br><a href="https://foofish.net/python-decorator.html" target="_blank" rel="noopener">理解 Python 装饰器看这一篇就够了</a><br><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449934543461c9d5dfeeb848f5b72bd012e1113d15000" target="_blank" rel="noopener">闭包</a></p>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/27/View源码解析之测量Measure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="洪荣宣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ww1.sinaimg.cn/large/8992ce25gy1fengvigdatj205k05k0t0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rongxuanhong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/27/View源码解析之测量Measure/" itemprop="url">View源码解析之测量Measure</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-27T22:46:55+08:00">2017-08-27</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/27/View源码解析之测量Measure/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments:</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/08/27/View源码解析之测量Measure/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<p>自定义 <code>View</code> 知识作为 <code>Android</code> 的一大基础，重要性不言而喻。而对 <code>View</code> 的测量则是第一步，因此我们必须掌握好它。而且,也只有理解了 <code>View</code> 的测量规则，然后我们才能更好地编写测量自定义控件的逻辑。</p>
<blockquote>
<p>注：本源码基于SDK25  </p>
</blockquote>
<p><strong>我们先来看看 <code>View</code>中的测量相关代码</strong>。</p>
<h1 id="MeasureSpec解析"><a href="#MeasureSpec解析" class="headerlink" title="MeasureSpec解析"></a>MeasureSpec解析</h1><hr>
<p><code>MeasureSpec</code> 封装了父 <code>ViewGroup</code> 传递给子 <code>View</code> 的一些布局必要条件。其代表了宽度和高度信息。而这宽度或者高度的信息都是由测量尺寸 <code>size</code>  和测量模式 <code>mode</code> 组成。那么，有了父<code>ViewGroup</code>要求的测量信息 <code>MeasureSpec</code> ，子 <code>View</code> 就能够知悉自己应该能有多大，测出的结果才能符合 <code>ViewGroup</code>对自身的约束。总之，该类在父 <code>ViewGroup</code>  和子 <code>view</code> 之间进行信息传递。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code>public static class MeasureSpec {
    private static final int MODE_SHIFT = 30;
    //移位的掩码，掩码的作用是屏蔽一部分二进制位，获取另一部分二进制位信息
    //此处将0x3(11)左移30位后得到 32位二进制 1100 0000 0000 0000 0000...(共30个0)正数左移低位补0
    private static final int MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT;

    /** @hide */
    @IntDef({UNSPECIFIED, EXACTLY, AT_MOST})
    @Retention(RetentionPolicy.SOURCE)
    public @interface MeasureSpecMode {}

    /**
     * 测量模式其一，parent对子view没有约束信息，子view想多大就多大,
     * 此时view就不需要考虑parent给的size了。
     * 左移后32位二进制 0000 0000 0000 0000 0000...(共30个0)
     */

    public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;

    /**
     * 测量模式其二，parent已经为子view确定了精确的尺寸信息，子view必须按照parent的约束
     * 进行测量。其中精确的尺寸信息包括宽高为xxxdp和match_parent两种布局参数。
     * 比如parent确定size为100dp给子view，那么子view就只能是100dp或者自己确定的尺寸(&gt;0dp)。
     * 左移后32位二进制 0100 0000 0000 0000 0000...(共30个0)
     */
    public static final int EXACTLY     = 1 &lt;&lt; MODE_SHIFT;

    /**
     * 测量模式其三，子view能够尽可能的大，但不能超过parent约束的尺寸。
     * 左移后32位二进制 1000 0000 0000 0000 0000...(共30个0)
     */
    public static final int AT_MOST     = 2 &lt;&lt; MODE_SHIFT;

    /**
     * 此方法为基于给定的测量尺寸size和测量模式mode重新生成新的测量规格信息.
     */
    public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size,
                                      @MeasureSpecMode int mode) {
        if (sUseBrokenMakeMeasureSpec) {
            //此处考虑兼容API17及以下,不再深究
            return size + mode;
        } else {
            //利用掩码分别取出size信息(低30位)，以及高2位mode信息，再进行位与操作，得到新的测量规格信息
            return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);
        }
    }

    /**
     **考虑兼容的方法，不深究，
     */
    public static int makeSafeMeasureSpec(int size, int mode) {
        if (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) {
            return 0;
        }
        return makeMeasureSpec(size, mode);
    }

    /**
     * 利用掩码取出测量规格的高2位信息得到测量模式并返回。
     */
    @MeasureSpecMode
    public static int getMode(int measureSpec) {
        //noinspection ResourceType
        return (measureSpec &amp; MODE_MASK);
    }

    /**
     * 利用掩码取出测量尺寸的低30位信息得到测量模式并返回。返回的尺寸单位为px
     */
    public static int getSize(int measureSpec) {
        return (measureSpec &amp; ~MODE_MASK);
    }
    /**
    *根据偏差值对测量规格进行调整，重新生成调整后的测量规格并返回
    */
    static int adjust(int measureSpec, int delta) {
        final int mode = getMode(measureSpec);
        int size = getSize(measureSpec);
        if (mode == UNSPECIFIED) {//此模式下不需要调整测量规格直接返回。

            return makeMeasureSpec(size, UNSPECIFIED);
        }
        size += delta;
        if (size &lt; 0) {
            Log.e(VIEW_LOG_TAG, &quot;MeasureSpec.adjust: new size would be negative! (&quot; + size +
                    &quot;) spec: &quot; + toString(measureSpec) + &quot; delta: &quot; + delta);
            size = 0;
        }
        return makeMeasureSpec(size, mode);
    }  
</code></pre><h1 id="measure-源码解析"><a href="#measure-源码解析" class="headerlink" title="measure()源码解析"></a>measure()源码解析</h1><p>此方法作用是根据 <code>parent</code>提供的宽高测量规格参数，来搞清view究竟有多大。但真正测量的方法是调用 <code>onMeasure()</code>，measure()帮我们做了一些逻辑处理，包括测量结果缓存等等，因此我们只要重写<code>onMeasure()</code> 方法即可，接下来我们来具体看下源码，分析分析流程。  </p>
<pre><code>public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
    //指定Parent的layoutMode为optical bound 时额外的判断，以修正测量规格。但此特性很少用，略过
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int oWidth = insets.left + insets.right;
        int oHeight = insets.top + insets.bottom;
        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);
        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
    }

    //1.将int型widthMeasureSpec强转为64位的long型并左移32位，此时宽度信息处于高32位
    //2.再将int型heightMeasureSpec强转为64位的long型并和0xffffffffL进行位与，屏蔽高32为，得到了低32位的高度信息
    //3.最后两者位或后组成了一个64位的long型变量。里面存储了宽度和高度的规格信息。
    long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;

    //定义缓存的集合
    if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);

    //1.mPrivateFlags是一个包含view的各种状态信息的变量，一般都是通过和相应状态的掩码位与，来检查是否具备相应的状态信息。
    //2.此处就是检测view是否有强制布局的标记
    final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;


    //1.检测测量规格是否有变化
    //2.检测测量模式是否为MeasureSpec.EXACTLY
    //3.检测当前控件的大小是否匹配parent的测量尺寸
    //4.根据1、2、3判断是否需要布局,其中sAlwaysRemeasureExactly为一个兼容API23及以下的变量,表示都需要重新布局
    final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec
            || heightMeasureSpec != mOldHeightMeasureSpec;
    final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY
            &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;
    final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)
            &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);
    final boolean needsLayout = specChanged
            &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);

    if (forceLayout || needsLayout) {//强制布局或者需要布局时都进入
        //先去除view中测量尺寸已设置的标记
        mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;

        //rtl相关略过，感兴趣了解即可
        resolveRtlPropertiesIfNeeded();

        //接下来主要判断是从缓存中获取测量信息呢，还是执行测量工作呢
        //1.若view标记了强制布局，那么进入第一个条件,调用onMeasure()，开始真正的测量工作，并且必须设置测量尺寸返回
        //接下来去除布局之前需要测量的标记，以便layout()过程中知道view已经完成测量了。
        //2.根据key从缓存集合中取出含有宽高测量规格信息的64为long值value.
        //首先，对value右移32位，高位补0，再向下强转得到32位int型的mMeasuredWidth，
        // 其次，直接对value进行向下强转得到原64位value的低32位信息，即mMeasuredHeight，
        //最后，调用setMeasuredDimensionRaw()设置view的测量尺寸,并加入布局之前需要测量标记
        int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);
        if (cacheIndex &lt; 0 || sIgnoreMeasureCache) {
            // measure ourselves, this should set the measured dimension flag back
            onMeasure(widthMeasureSpec, heightMeasureSpec);
            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        } else {
            long value = mMeasureCache.valueAt(cacheIndex);
            // Casting a long to int drops the high 32 bits, no mask needed
            setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);
            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }

        //检查上述流程是否都有调用设置view尺寸的方法setMeasuredDimension(),否则报错
        if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;
                    + getClass().getName() + &quot;#onMeasure() did not set the&quot;
                    + &quot; measured dimension by calling&quot;
                    + &quot; setMeasuredDimension()&quot;);
        }
        //加入需要布局的标记
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    //记录宽度和高度的测量规格
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
    //以键值对形式，mMeasuredWidth信息存long型高32位，mMeasuredHeight信息存long型低32位，并位与为一个64位值，缓存到集合中
    mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |
            (long) mMeasuredHeight &amp; 0xffffffffL); 
}  
</code></pre><h1 id="onMeasure源码分析"><a href="#onMeasure源码分析" class="headerlink" title="onMeasure源码分析"></a>onMeasure源码分析</h1><p>此方法的作用是测量 <code>view</code>及其内容，以确定测量宽度以及测量高度。并且必须调用 <code>setMeasuredDimension(int, int)</code> 以保存测量宽高信息。  </p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    //根据默认的view的宽高大小和对应的parent的测量规格,设置测量尺寸并保存宽高信息
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

protected int getSuggestedMinimumWidth() {
    //判断view的背景是否为空，若是返回xml设置的minWidth，否则返回背景的最小宽度
    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
}
//getSuggestedMinimumHeight() 同理

public static int getDefaultSize(int size, int measureSpec) {
    int result = size;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);
     //根据size和测量规格中的测量尺寸和测量模式分情况设置结果尺寸
    switch (specMode) {
        //parent未指定约束信息，直接取size
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
            //parent的约束信息为如下两种时，直接设置测量尺寸作为结果尺寸
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
    }
    return result;
}

protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {
    //指定layoutMode为optical bound 时额外的判断，以修正测量规格。但此特性很少用，略过
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int opticalWidth = insets.left + insets.right;
        int opticalHeight = insets.top + insets.bottom;

        measuredWidth += optical ? opticalWidth : -opticalWidth;
        measuredHeight += optical ? opticalHeight : -opticalHeight;
    }
    //真正设置view尺寸的方法
    setMeasuredDimensionRaw(measuredWidth, measuredHeight);
}

private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {
    //保存当前view的测量宽度和高度
    mMeasuredWidth = measuredWidth;
    mMeasuredHeight = measuredHeight;
    //设置view的测量尺寸已设置标记(此标记若不设置，则会导致measure()方法中报错)
    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
}  
</code></pre><h1 id="resolveSize源码解析"><a href="#resolveSize源码解析" class="headerlink" title="resolveSize源码解析"></a>resolveSize源码解析</h1><p>此方法是能够使你期望的大小和状态与 <code>MeasureSpec</code> 追加的约束信息一致的工具方法，也就是说仍是基于当前传入的约束信息去计算最终的大小。除非约束的测量尺寸不同于你所期望的，否则将会默认以你期望的尺寸返回。</p>
<pre><code> public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) {
    //获取传入的测量模式、测量尺寸
    final int specMode = MeasureSpec.getMode(measureSpec);
    final int specSize = MeasureSpec.getSize(measureSpec);
    final int result;

    switch (specMode) {
        case MeasureSpec.AT_MOST://parent约束的测量模式AT_MOST，specSize为view的最大尺寸
            if (specSize &lt; size) {//取specSize为结果尺寸，并加入MEASURED_STATE_TOO_SMALL标记
                result = specSize | MEASURED_STATE_TOO_SMALL;
            } else {//否则返回期望的结果尺寸
                result = size;
            }
            break;
        case MeasureSpec.EXACTLY://parent约束了尺寸，以该测量尺寸返回
            result = specSize;
            break;
        case MeasureSpec.UNSPECIFIED:  //此模式下同默认返回的情况
        default:
            result = size;
    }
    return result | (childMeasuredState &amp; MEASURED_STATE_MASK);//返回高8为状态位信息的结果尺寸
}  
</code></pre><blockquote>
<p>注意:上述方法中涉及到两张尺寸，不要搞混。一个是<code>parent</code>约束<code>child</code>的测量尺寸，而另一个是你自己计算后或者你期望 <code>child</code> 多大传入的尺寸,最终计算结果需要综合两者，进而得到一个最符合的尺寸。  </p>
</blockquote>
<p><strong>接下来我们再来看看 <code>ViewGroup</code> 中有关测量的源码</strong>。  </p>
<h1 id="measureXXX"><a href="#measureXXX" class="headerlink" title="measureXXX()"></a>measureXXX()</h1><p>我们先看看几个以 <code>measure</code> 开头的方法及一些涉及到的常用方法。  </p>
<h2 id="measureChildren"><a href="#measureChildren" class="headerlink" title="measureChildren()"></a>measureChildren()</h2><p>此方法为 <code>ViewGroup</code> 测量 <code>children</code> 的方法。主要就是遍历每个 <code>child</code> 进行测量。</p>
<pre><code>protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
    //获取child的个数 我们会常利用getChildCount()来返回child的个数
    final int size = mChildrenCount;
    //ViewGroup中children的集合
    final View[] children = mChildren;
    //遍历每个child
    for (int i = 0; i &lt; size; ++i) {
        final View child = children[i];
        //如果child的可见性不是GONE，则开始测量child
        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
        }
    }
}
</code></pre><h2 id="measureChild"><a href="#measureChild" class="headerlink" title="measureChild()"></a>measureChild()</h2><p>该方法结合 <code>ViewGroup</code> 对 <code>child</code> 的宽高约束信息，测量自己。</p>
<pre><code> protected void measureChild(View child, int parentWidthMeasureSpec,
        int parentHeightMeasureSpec) {
    //获取child的布局参数
    final LayoutParams lp = child.getLayoutParams();
    //调用getChildMeasureSpec()重新确定child的宽高约束信息，此处考虑了parent的padding对测量child的影响
    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
            mPaddingLeft + mPaddingRight, lp.width);
    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
            mPaddingTop + mPaddingBottom, lp.height);
    //child根据约束信息开始测量自身
    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
</code></pre><h2 id="measureChildWithMargins"><a href="#measureChildWithMargins" class="headerlink" title="measureChildWithMargins()"></a>measureChildWithMargins()</h2><p>此方法考虑了 <code>ViewGroup</code> 的 <code>padding</code> 以及 <code>children</code> 的 <code>margin</code> 等因素，以便对<code>children</code> 更加精确的测量，大体流程无异于 <code>measureChild()</code> ，后者其实亦包含了前者。</p>
<pre><code>protected void measureChildWithMargins(View child,
        int parentWidthMeasureSpec, int widthUsed,
        int parentHeightMeasureSpec, int heightUsed) {
    //为了获取margin我们需要拿到child的MarginLayoutParams实例
    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();
    //重新生成对child的测量约束信息。比前者多了margin，以及Parent中已使用的空间。
    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin
                    + widthUsed, lp.width);
    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin
                    + heightUsed, lp.height);
    //child根据约束信息开始测量自身
    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
} 
</code></pre><h2 id="getChildMeasureSpec"><a href="#getChildMeasureSpec" class="headerlink" title="getChildMeasureSpec()"></a>getChildMeasureSpec()</h2><p>此方法返回了对 <code>child</code>的一个最佳的测量规格。因为它不仅结合了 <code>ViewGroup</code> 对 <code>child</code> 的约束信息，也结合了自身 <code>LayoutParams</code>的信息，最终计算得到了一个 <code>child</code> 最佳的尺寸和模式，也即<code>child</code> 的最佳测量规格，我们先来看看源码：  </p>
<pre><code>public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
    获取ViewGroup对children的测量模式和测量尺寸约束信息
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);

    //考虑了ViewGroup padding属性额外占据的空间，我们先去掉，得到一个children有效的测量尺寸
    int size = Math.max(0, specSize - padding);

    //记录child的最终测量尺寸和测量模式的变量
    int resultSize = 0;
    int resultMode = 0;
    //根据ViewGroup的测量模式，讨论children最终的约束信息
    switch (specMode) {
    //若是MeasureSpec.EXACTLY，ViewGroup的layoutParams可以是xxxdp或者MATCH_PARENT
    case MeasureSpec.EXACTLY:
        if (childDimension &gt;= 0) {
            //child的宽度或高度值为具体的xxxdp时，即child确定需要多大了，那么直接给它分配。
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
            //child的宽度或高度值为LayoutParams.MATCH_PARENT时，表示child想要和ViewGroup一样大，那就满足它。
            resultSize = size;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
            //child的宽度或高度值为LayoutParams.WRAP_CONTENT，表示child决定自己的大小，有多少内容就占用多大，但是你不能超过ViewGroup
            给你约束的尺寸。
            resultSize = size;//分配最大的尺寸给child，不能再多了
            resultMode = MeasureSpec.AT_MOST;
        }
        break;

    //ViewGroup的layoutParams只能是WRAP_CONTENT，它对child约束了一个最大容纳尺寸
    case MeasureSpec.AT_MOST:
        if (childDimension &gt;= 0) {//此处同上,
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
          //此处大致同上，唯一的区别在于测量模式。虽然child的LayoutParams是MATCH_PARENT,我们可能会认为测量模式应该是MeasureSpec.EXACTLY，
          但是你想啊ViewGroup的测量模式是MeasureSpec.AT_MOST，意味者ViewGroup的大小是由自身内容实际占用的大小决定，而这并不是精确的尺寸，
          那么它的child就更不可能是精确模式了，即MeasureSpec.EXACTLY,至多只能和ViewGroup测量模式一样咯。
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
            //此处同上
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        }
        break;

    // ViewGroup对child不施加约束信息，意味着child要多大都可以。
    //除非child具体指定大小，否则都是给child设置resultSize为0，其模式为 MeasureSpec.UNSPECIFIED，表示child想多大就多大，ViewGroup不控制。
    而此处的sUseZeroUnspecifiedMeasureSpec为兼容性处理变量，再SDK_INT&lt;M，始终是true，而高于此则为false，可能在高版本上有更好的解决方案吧。
    我们暂且考虑resultSize为0的情况吧
    case MeasureSpec.UNSPECIFIED:
        if (childDimension &gt;= 0) {
            //此处同上
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
            resultMode = MeasureSpec.UNSPECIFIED;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
            resultMode = MeasureSpec.UNSPECIFIED;
        }
        break;
    }
    //最后返回child新的测量规格
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}  
</code></pre><p>其实以上方法的流程，我们可以总结为这样一张表格，可以显得更加直观。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">EXACTLY</th>
<th style="text-align:center">AT_MOST</th>
<th style="text-align:right">UNSPECIFIED</th>
</tr>
</thead>
<tbody>
<tr>
<td>具体大小(100dp)</td>
<td style="text-align:center">childDimension+EXACTLY</td>
<td style="text-align:center">childDimension+EXACTLY</td>
<td style="text-align:right">childDimension+EXACTLY</td>
</tr>
<tr>
<td>MATCH_PARENT</td>
<td style="text-align:center">size+ EXACTLY</td>
<td style="text-align:center">size+AT_MOST</td>
<td style="text-align:right">size(0)+UNSPECIFIED</td>
</tr>
<tr>
<td>WRAP_CONTENT</td>
<td style="text-align:center">size+AT_MOST</td>
<td style="text-align:center">size+AT_MOST</td>
<td style="text-align:right">size(0)+UNSPECIFIED</td>
</tr>
</tbody>
</table>
</div>
<p>表格的第一行为 <code>ViewGroup</code> 对 <code>children</code> 对测量模式，第一列为 <code>children</code> 具体的 <code>LayoutParams</code> ，结果为 <code>children</code> 最终的测量尺寸和测量模式。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在第一部分，首先，我们从 <code>MeasureSpec</code>这个类切入，详细解析了三大测量模式的含义，以及指定新测量规格的方法等；其次，分析了 <code>measure()</code> ，知道了 <code>View</code> 中其实是有缓存测量过的信息的，否则 <code>view</code> 才会重新测量,也知道了真正的测量工作其实是在 <code>onMeasure ()</code> 方法中进行，因此我们可以重写该方法，重新定义 <code>view</code>的测量逻辑；再来，我们通过调用 <code>setMeasureDimension()</code>为 <code>view</code>重新定义了新的宽度和高度；最后，我们又解析了方法 <code>resolveSize()</code>的作用，它作为一个工具方法能够辅助你进行测量工作。  </p>
<p>在第二部分，首先我们研究了 <code>ViewGroup</code>中测量 <code>children</code> 的方法 <code>measureChildren()</code> ，知道其实它是通过遍历每个child进行测量的，然后进一步研究了测量单个 <code>child</code> 的方法 <code>measureChild()</code> 以及 <code>measureChildWithMargins()</code> ，而两者内部其实关键在于 <code>getChildMeasureSpec()</code> 的调用，该方法对于 <code>ViewGroup</code> 与 <code>Children</code> 之间可能存在的各种布局关系进行了分类讨论，以至于能够得到一个最佳的 <code>child</code> 测量规格。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p><a href="http://blog.csdn.net/iispring/article/details/49403315" target="_blank" rel="noopener">源码解析Android中View的measure量算过程</a><br>感谢您看到这里，期望留下您的印迹。</p>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/17/DialogFragment源码解析与应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="洪荣宣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ww1.sinaimg.cn/large/8992ce25gy1fengvigdatj205k05k0t0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rongxuanhong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/17/DialogFragment源码解析与应用/" itemprop="url">DialogFragment源码解析与应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-17T21:57:23+08:00">2017-08-17</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/17/DialogFragment源码解析与应用/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments:</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/08/17/DialogFragment源码解析与应用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p><strong>版权声明：本文为博主原创文章，未经博主允许不得转载</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<p><code>DialogFragment</code> 是继承于 <code>Fragment</code> 的子类，因而其具备了 <code>Fragment</code> 的特性，如生命周期。而其内部实际控制了一个 <code>Dialog</code> 对象，并通过当前 <code>DialogFragment</code>所依附的 <code>Activity</code> 的 <code>FragmentManager</code> 来对其进行管理与控制，也即将其当做一个普通的 <code>Fragment</code> 那样来管理。</p>
<blockquote>
<p>注:<code>dialog</code> 拥有自己的窗体 <code>window</code>,意味着它可以自己接收输入事件，处理事件，并且决定自己何时消失。</p>
</blockquote>
<h1 id="浅谈生命周期"><a href="#浅谈生命周期" class="headerlink" title="浅谈生命周期"></a>浅谈生命周期</h1><hr>
<p><code>DialogFragment</code> 与 <code>Dialog</code> 同生同死,因为 <code>DialogFragment</code> 需要监听 <code>Dialog</code>的显示与关闭,并做出反映。而这两个操作关联到了 <code>DialogFragment</code> 加入到 <code>FragmentManager</code> 中和从其中移除。这样一来 <code>Dialog</code>的创建与销毁也随着 <code>DialogFragment</code> 的生命周期而走了。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><pre><code>public void setStyle(@DialogStyle int style, @StyleRes int theme) {
    mStyle = style;
    if (mStyle == STYLE_NO_FRAME || mStyle == STYLE_NO_INPUT) {
        mTheme = android.R.style.Theme_Panel;
    }
    if (theme != 0) {
        mTheme = theme;
    }
} 
</code></pre><p>此方法为对话框设置样式与主题。其中样式有 <strong>4</strong> 个可选，一般用得比较多的是<code>STYLE_NO_TITLE</code>(指定对话框无标题模式),而主题默认的话可填0，若是自定义主题，可在<code>style</code>文件下新增一个样式，然后继承<code>Theme.Dialog</code>修改你期望的主题即可。</p>
<blockquote>
<p>注意: 此方法若要生效一定要在对话框未创建之前设置，否则失效。下面我们还会谈到。</p>
</blockquote>
<pre><code> public void show(FragmentManager manager, String tag) {
    mDismissed = false;
    mShownByMe = true;
    FragmentTransaction ft = manager.beginTransaction();
    ft.add(this, tag);
    ft.commit();
}
</code></pre><p>此方法就是控制对话框的显示，调用即可。其实就是类似普通的 <code>Fragment</code>的显示操作逻辑,获取<code>FragmentManager</code>来管理当前的对话框。是不是似曾相识？ </p>
<pre><code> public void dismiss() {
    dismissInternal(false);
}
void dismissInternal(boolean allowStateLoss) {
    if (mDismissed) {
        return;
    }
    mDismissed = true;
    mShownByMe = false;
    if (mDialog != null) {
        mDialog.dismiss();
        mDialog = null;
    }
    mViewDestroyed = true;
    if (mBackStackId &gt;= 0) {
        getFragmentManager().popBackStack(mBackStackId,
                FragmentManager.POP_BACK_STACK_INCLUSIVE);
        mBackStackId = -1;
    } else {
        FragmentTransaction ft = getFragmentManager().beginTransaction();
        ft.remove(this);
        if (allowStateLoss) {
            ft.commitAllowingStateLoss();
        } else {
            ft.commit();
        }
    } 
</code></pre><p>此方法控制<code>DialogFragment</code>的关闭。我们看到在<code>void dismissInternal()</code>方法内会判断当前的<code>Dialog</code>对象 <code>mDialog</code>是否为空，否则就调用<code>Dialog</code> 的 <code>dismiss()</code> 关闭对话框。而剩下的代码都是<code>DialogFragment</code>为了管理自己的后续操作。比如退栈操作,移除 <code>Fragment</code>。</p>
<pre><code> public Dialog getDialog() {
    return mDialog;
}
</code></pre><p>此方法用于获取 <code>DialogFragment</code> 内的 <code>Dialog</code> 对象。我们之后要对对话框的尺寸改变、去除标题、设置背景、都需要获取该实例。</p>
<pre><code> public void setCancelable(boolean cancelable) {
    mCancelable = cancelable;
    if (mDialog != null) mDialog.setCancelable(cancelable);
}
</code></pre><p>望名知义，就是设置对话框是否可以取消。内部还是调用 <code>Dialog</code>的方法  </p>
<pre><code> public void setShowsDialog(boolean showsDialog) {
    mShowsDialog = showsDialog;
}  
</code></pre><p>此方法控制当前 <code>DialogFragment</code>是否作为对话框而存在，否则视作普通的 <code>Fragment</code>来使用。而如果你把它当前普通的 <code>Fragment</code>加入到关联的 <code>Activity</code>中，那么<code>mShowsDialog</code> 会被初始化为 <strong>true</strong>。 </p>
<pre><code> @Override
public void onAttach(Context context) {
    super.onAttach(context);
    if (!mShownByMe) {
        mDismissed = false;
    }
}

@Override
public void onDetach() {
    super.onDetach();
    if (!mShownByMe &amp;&amp; !mDismissed) {
        mDismissed = true;
    }
}

@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    mShowsDialog = mContainerId == 0;

    if (savedInstanceState != null) {
        mStyle = savedInstanceState.getInt(SAVED_STYLE, STYLE_NORMAL);
        mTheme = savedInstanceState.getInt(SAVED_THEME, 0);
        mCancelable = savedInstanceState.getBoolean(SAVED_CANCELABLE, true);
        mShowsDialog = savedInstanceState.getBoolean(SAVED_SHOWS_DIALOG, mShowsDialog);
        mBackStackId = savedInstanceState.getInt(SAVED_BACK_STACK_ID, -1);
    }
}  
</code></pre><p>以上的三个方法都是 重写 <code>Fragment</code> 中的生命周期方法。前两个主要是设置相应的标志位。<br>而在 <code>onCreate()</code> 中主要是从保存的实例状态中获取相应信息（之前在 <code>onSaveInstanceState()</code> 中设置的）。  </p>
<pre><code>/** @hide */
@RestrictTo(LIBRARY_GROUP)
@Override
public LayoutInflater getLayoutInflater(Bundle savedInstanceState) {
    if (!mShowsDialog) {
        return super.getLayoutInflater(savedInstanceState);
    }

    mDialog = onCreateDialog(savedInstanceState);

    if (mDialog != null) {
        setupDialog(mDialog, mStyle);

        return (LayoutInflater) mDialog.getContext().getSystemService(
                Context.LAYOUT_INFLATER_SERVICE);
    }
    return (LayoutInflater) mHost.getContext().getSystemService(
            Context.LAYOUT_INFLATER_SERVICE);
}

/** @hide */
@RestrictTo(LIBRARY_GROUP)
public void setupDialog(Dialog dialog, int style) {
    switch (style) {
        case STYLE_NO_INPUT:
            dialog.getWindow().addFlags(
                    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |
                            WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE);
            // fall through...
        case STYLE_NO_FRAME:
        case STYLE_NO_TITLE:
            dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
    }
}  
public Dialog onCreateDialog(Bundle savedInstanceState) {
    return new Dialog(getActivity(), getTheme());
}
</code></pre><p>最上两个方法是被隐藏的。<code>getLayoutInflater()</code> 中首先判断是否显示为一个对话框，若是才来到下面的逻辑。在这里我们发现，方法内调用了<code>onCreateDialog()</code>来获得一个对话框实例。如果实例存在，那么才开始配置对话框<strong>(注意：我们发现此处获取前述的 <code>setStyle()</code>传进来的值，因而该方法的调用必须早于此，也就是说你至少可以在 <code>onCreateDialog()</code>中进行设置)</strong>，此时，方法返回与对话框上下文关联的布局加载器。<br>接下来我们看<code>setupDialog()</code>。方法内根据存入的样式，对对话框实例进行一系列的设置，比如禁止获取焦点、不可触摸、设置无标题。<br>另外，在 <code>onCreateDialog()</code> 返回了一个新的对话框实例。在此，我们注意到，如果你想实现一些Dialog子类的对话框,比如 <code>AlertDialog</code>，那么你就可以重写该方法，返回你要创建的<code>Dialog</code> 子类实例。  </p>
<pre><code>@Override
public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);

    if (!mShowsDialog) {
        return;
    }

    View view = getView();
    if (view != null) {
        if (view.getParent() != null) {
            throw new IllegalStateException(
                    &quot;DialogFragment can not be attached to a container view&quot;);
        }
        mDialog.setContentView(view);
    }
    final Activity activity = getActivity();
    if (activity != null) {
        mDialog.setOwnerActivity(activity);
    }
    mDialog.setCancelable(mCancelable);
    mDialog.setOnCancelListener(this);
    mDialog.setOnDismissListener(this);
    if (savedInstanceState != null) {
        Bundle dialogState = savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG);
        if (dialogState != null) {
            mDialog.onRestoreInstanceState(dialogState);
        }
    }
}  
</code></pre><p>当<code>Activity</code>创建完成后回调。若<code>mShowsDialog</code>为<strong>false</strong>，那么以下逻辑不再执行。<br>否则获取当前 <code>DialogFragment</code> 的根布局实例 <code>view</code>,并将其作为对话框的内容，加入其中。接下来把对话框与 <code>Activity</code> 进行绑定。接下来就是对话框的配置，包括注册取消监听，关闭监听。最后保存相关状态到 <code>savedInstanceState</code>,以便重建时利用。</p>
<pre><code> @Override
public void onStart() {
    super.onStart();

    if (mDialog != null) {
        mViewDestroyed = false;
        mDialog.show();
    }
}  
</code></pre><p>此方法很重要。对话框真正显示就在此后。内容调用了 <code>mDialog</code> 的<code>show()</code>方法，将对话框显示出来(依附于 <code>Fragment</code>)</p>
<pre><code>     @Nullable
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
        @Nullable Bundle savedInstanceState) {
    return null;
}
</code></pre><p>此方法为 <code>Fragment</code> 中的方法，为空实现，它交给子类去加载一个 <strong>contentView</strong>,再由<code>Fragment</code> 来处理。而我们对话框的内容布局就是在此处进行加载，以便返回一个对话框的布局给 <code>Fragment</code> 去处理。</p>
<blockquote>
<p>注意：<code>onCreateDialog()</code>比 <code>onCreateView()</code> 先一步执行。因为在 <code>Fragment</code>中调用<code>onCreateView()</code> 时需要拿到一个布局加载器<code>LayoutInflater</code>,而<code>DialogFragmet</code>中是通过上述的一个方法—<code>getLayoutInflater()</code>来返回一个与对话框有关的上下文布局加载器,<code>onCreateDialog()</code>就在其中被调用，因而我们很容易就可以知道两者的执行次序。  </p>
</blockquote>
<h1 id="几类常见应用"><a href="#几类常见应用" class="headerlink" title="几类常见应用"></a>几类常见应用</h1><h2 id="普通对话框"><a href="#普通对话框" class="headerlink" title="普通对话框"></a>普通对话框</h2><pre><code>public class CommonDialogFragment extends DialogFragment {

private static final String TAG = &quot;CommonDialogFragment&quot;;


@Nullable
@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
     Dialog dialog = getDialog();
    DisplayMetrics dm = DensityUtil.getDisplayMetrics(getActivity());
    int width = dm.widthPixels;
    if (dialog != null) {
        dialog.getWindow().setLayout(width * 2 / 3, width / 2);
        dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
        dialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));//去除多余的padding
    }
    dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
    View view = inflater.inflate(R.layout.time, container, false);
    ListView mListView = (ListView) view.findViewById(R.id.listview);
    mListView.setAdapter(new MyAdapter(getActivity()));
    return view;
    }
}
</code></pre><p>这类很简单，一般只要重写 <code>onCreateView()</code>，和<code>Fragment</code>中的做法一样。只是需要额外配置对话框的一些设置，我们下面再统一叙述。  </p>
<h2 id="警告对话框"><a href="#警告对话框" class="headerlink" title="警告对话框"></a>警告对话框</h2><pre><code>public class MyAlerDialog extends DialogFragment {

private static final String TAG = &quot;RoundCornerDialog&quot;;

@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {
    return new AlertDialog.Builder(getActivity()).setMessage(&quot;我是对话框&quot;).setTitle(&quot;警告&quot;).setIcon(R.mipmap.ic_launcher).create();
}

@Nullable
@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
    Dialog dialog = getDialog();
    DisplayMetrics dm = DensityUtil.getDisplayMetrics(getActivity());
    int width = dm.widthPixels;
    if (dialog != null) {
        dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
        dialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));//去除多余的padding
        dialog.getWindow().setLayout(width * 2 / 3, width / 2);
    }
    return super.onCreateView(inflater, container, savedInstanceState);
}
</code></pre><p>}</p>
<h2 id="圆角对话框"><a href="#圆角对话框" class="headerlink" title="圆角对话框"></a>圆角对话框</h2><p>圆角对话框与上述两张对话框创建流程无异，只需对布局额外加上一层drawable绘制的圆角背景层即可</p>
<blockquote>
<p>注意: 若加了圆角背景层仍没有圆角化，那么你需要对圆角背景层再 加上padding属性即可解决。</p>
</blockquote>
<h1 id="对话框的配置"><a href="#对话框的配置" class="headerlink" title="对话框的配置"></a>对话框的配置</h1><h2 id="去标题化"><a href="#去标题化" class="headerlink" title="去标题化"></a>去标题化</h2><ol>
<li>调用<code>setStyle()</code>传入<code>STYLE_NO_TITLE</code>,必须在<code>Dialog</code>创建之前调用方可生效。</li>
<li>定义自己的主题，设置 <code>windowNoTitle</code>属性为<strong>true</strong></li>
</ol>
<h2 id="背景透明化"><a href="#背景透明化" class="headerlink" title="背景透明化"></a>背景透明化</h2><pre><code>getDialog().getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)。
</code></pre><p>我们一般都会加上，没有设置有可能出现多余的padding，它可让整个<code>Window</code>透明化。</p>
<h2 id="设置Dialog的尺寸"><a href="#设置Dialog的尺寸" class="headerlink" title="设置Dialog的尺寸"></a>设置Dialog的尺寸</h2><p>由于 <code>Dialog</code> 属于 <code>Window</code> 级别，属于独立窗体，因而要改变 <code>Dialog</code> 的尺寸实际上就上改变窗体 <code>Window</code> 的尺寸，而如果你对布局修改尺寸是毫无效果的。<br>我们通过<code>getDialog().getWindow().setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)</code>来设置对话框具体宽高或全屏就够了。</p>
<h2 id="设置对话框方位"><a href="#设置对话框方位" class="headerlink" title="设置对话框方位"></a>设置对话框方位</h2><p>实际还是控制<code>window</code>这个对象，调用它的方法<code>setGravity()</code>即可。  </p>
<blockquote>
<p>注意： 但凡涉及到获取对话框所在的<code>window</code>对象时，都必须在对话框已经创建了之后调用。</p>
</blockquote>
<h2 id="配置style样式定制主题"><a href="#配置style样式定制主题" class="headerlink" title="配置style样式定制主题"></a>配置style样式定制主题</h2><p>我们查看源码可知道对话框的默认主题基础自<code>Theme.Dialog</code>，那么我们便可以继承整个主题，修改默认主题中的属性值来达到我们想要的效果，下面贴出对话框默认的主题。</p>
<pre><code>    &lt;style name=&quot;Theme.Dialog&quot;&gt;
    &lt;!--配置window有无边框--&gt;
    &lt;item name=&quot;windowFrame&quot;&gt;@null&lt;/item&gt;
    &lt;!--配置window标题样式--&gt;
    &lt;item name=&quot;windowTitleStyle&quot;&gt;@style/DialogWindowTitle&lt;/item&gt;
    &lt;!--配置window背景层--&gt;常用
    &lt;item name=&quot;windowBackground&quot;&gt;@drawable/panel_background&lt;/item&gt;
    &lt;!--配置window是否浮在上面--&gt;
    &lt;item name=&quot;windowIsFloating&quot;&gt;true&lt;/item&gt;
    &lt;!--配置window是否浮在上面--&gt;
    &lt;!--配置window有无标题 --&gt; 常用
    &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;
    &lt;!--配置window进入退出动画 --&gt; 常用
    &lt;item name=&quot;windowAnimationStyle&quot;&gt;@style/Animation.Dialog&lt;/item&gt;
    &lt;!--配置window外部是否可触摸--&gt;
    &lt;item name=&quot;windowCloseOnTouchOutside&quot;&gt;@bool/config_closeDialogWhenTouchOutside&lt;/item&gt;
    ....此处省略部分属性
    &lt;/style&gt;
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先，介绍了使用<code>DialogFragment</code> 的缘由以及好处，再来谈到了它的生命周期，这也是之所以使用这种方式来呈现对话框的关键所在。再接下来，我们从源码的角度，详细剖析了各个方法的作用、联系，以及调用的时机以及注意事项。再来介绍了<code>DialogFragment</code>的几种常见的应用，也可以说是常用的代码模版了。最后，介绍了配置对话框的一些常用的手段以及注意事项。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>感谢您看到这里，期望留下您的印迹。</p>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/30/一起看画笔Paint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="洪荣宣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ww1.sinaimg.cn/large/8992ce25gy1fengvigdatj205k05k0t0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rongxuanhong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/30/一起看画笔Paint/" itemprop="url">一起看画笔Paint</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-30T19:23:25+08:00">2017-07-30</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/30/一起看画笔Paint/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments:</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/30/一起看画笔Paint/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>Paint</strong> 可以决定你所画的几何图形、文本、位图的样式和颜色变化。</p>
<h1 id="mPaint-measureXX"><a href="#mPaint-measureXX" class="headerlink" title="mPaint.measureXX"></a>mPaint.measureXX</h1><h2 id="mPaint-MeasureText"><a href="#mPaint-MeasureText" class="headerlink" title="mPaint.MeasureText"></a>mPaint.MeasureText</h2><ol>
<li><p>方法1： </p>
<pre><code> float measureText (char[] text, int index, int count) 
</code></pre><p>作用：测量文字绘制时所占用的宽度。<br>对参数的解释:  </p>
<ul>
<li>text 待测试的字符数组</li>
<li>index 从第几个index开始测量</li>
<li>count 共测量多少个字符  </li>
</ul>
</li>
<li><p>方法2:</p>
<pre><code> float measureText (CharSequence text, int start, int end) 
</code></pre><p>对参数的解释：  </p>
<ul>
<li>text 待测试字符串</li>
<li>start 从start位置开始测量字符串</li>
<li>end  测量到字符串的end位置，但不包括.</li>
</ul>
</li>
<li><p>方法3：</p>
<pre><code> float measureText (String text, int start, int end)
</code></pre></li>
<li><p>例子:  </p>
<pre><code> char[] str=&quot;学习Paint&quot;.toCharArray();
 String string=&quot;学习Paint&quot;;
 float v1 = mPaint.measureText(string);
 Log.i(TAG,&quot;方法1=&quot;+v1);//测量&quot;学习Paint&quot;
 float v2 = mPaint.measureText(str,0,str.length-1);//只测量&quot;学习Pain&quot;
 Log.i(TAG,&quot;方法2=&quot;+v2);
 float v3=mPaint.measureText(string,1,string.length());//只测量&quot;习Paint&quot;
 Log.i(TAG,&quot;方法3=&quot;+v3);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhn77x6w5xj20hm02zdfs.jpg" alt=""><br>另外：<strong>mPaint.getTextWidths(String text, float[] widths)</strong>用于获取 <strong>text</strong> 中每个字符的宽度并返回到 <strong>widths</strong> 数组中，用到了<code>MeasureText</code> 方法  </p>
</li>
</ol>
<h1 id="mPaint-breakXXX"><a href="#mPaint-breakXXX" class="headerlink" title="mPaint.breakXXX"></a>mPaint.breakXXX</h1><h2 id="mPaint-breakText"><a href="#mPaint-breakText" class="headerlink" title="mPaint.breakText"></a>mPaint.breakText</h2><p>作用:测量指定宽度的文本宽度，超过指定宽度后截断。  </p>
<ol>
<li><p>方法1:  </p>
<pre><code> breakText(String text, boolean measureForwards, float maxWidth, float[] measuredWidth)  
</code></pre></li>
<li><p>方法2:  </p>
<pre><code> breakText(char[] text, int index, int count, float maxWidth, float[] measuredWidth)  
</code></pre></li>
<li><p>方法3:  </p>
<pre><code> breakText(CharSequence text, int start, int end, boolean measureForwards, float maxWidth, float[] measuredWidth)  
</code></pre></li>
<li>关键参数详解：  </li>
</ol>
<ul>
<li><strong>measureForwards</strong>：表示文字测量的方法，<strong>true</strong> 表示从左向右开始测量.  </li>
<li><strong>maxWidth</strong>:指定要测量的文本的最大宽度，也是是否截断文本的界限值.</li>
<li><strong>measuredWidth</strong>:用于接受数据,并将结果赋值给 <strong>measuredWidth[0]</strong>  </li>
</ul>
<h1 id="mPaint-setXXX"><a href="#mPaint-setXXX" class="headerlink" title="mPaint.setXXX"></a>mPaint.setXXX</h1><h2 id="mPaint-set"><a href="#mPaint-set" class="headerlink" title="mPaint.set"></a>mPaint.set</h2><p>为当前画笔copy一支画笔  </p>
<h2 id="mPaint-setAlpha"><a href="#mPaint-setAlpha" class="headerlink" title="mPaint.setAlpha"></a>mPaint.setAlpha</h2><p>方法: </p>
<pre><code>void setAlpha (int a)  
</code></pre><p>为设置透明值属性，a介于[0,255]之间</p>
<h2 id="mPaint-setARGB"><a href="#mPaint-setARGB" class="headerlink" title="mPaint.setARGB"></a>mPaint.setARGB</h2><p>方法： </p>
<pre><code>void setARGB (int a, int r, int g, int b) 
</code></pre><p>设置透明值和三基色  </p>
<h2 id="mPaint-setAntiAlias"><a href="#mPaint-setAntiAlias" class="headerlink" title="mPaint.setAntiAlias"></a>mPaint.setAntiAlias</h2><p>方法： </p>
<pre><code>void setAntiAlias (boolean aa)  
</code></pre><p>设置是否开启抗锯齿</p>
<h2 id="mPaint-setColor"><a href="#mPaint-setColor" class="headerlink" title="mPaint.setColor"></a>mPaint.setColor</h2><p>方法: </p>
<pre><code>void setColor (int color)  
</code></pre><p>设置画笔的颜色</p>
<h2 id="mPaint-setColorFilter"><a href="#mPaint-setColorFilter" class="headerlink" title="mPaint.setColorFilter"></a>mPaint.setColorFilter</h2><p>方法: </p>
<pre><code>ColorFilter setColorFilter (ColorFilter filter)  
</code></pre><p>设置或清除画笔的颜色过滤器,比如去掉图片的绿色  </p>
<h3 id="ColorFilter"><a href="#ColorFilter" class="headerlink" title="ColorFilter"></a>ColorFilter</h3><p>有三个子类可供设置  </p>
<ol>
<li><p><strong>LightingColorFilter</strong><br>作用：常用于模拟灯光效果<br>构造方法：</p>
<p> LightingColorFilter(int mul, int add) </p>
</li>
</ol>
<p>对参数的解释：  </p>
<pre><code>mul: 色彩倍增值,16进制的色彩值0xAARRGGBB。
add: 色彩增加值,16进制的色彩值0xAARRGGBB。  
</code></pre><p>计算公式:  </p>
<pre><code>     R&#39; = R * colorMultiply.R + colorAdd.R
     G&#39; = G * colorMultiply.G + colorAdd.G
     B&#39; = B * colorMultiply.B + colorAdd.B  
</code></pre><p>由16进制的与运算我们知道，任意的 <strong>0xAARRGGBB*0xFFFFFFFF=0xAARRGGBB</strong>,而再加上<strong>0x00000000</strong>，结果仍不变。故我们知道当 <strong>mul=0xFFFFFFFF,add=0x00000000</strong>,该过滤器并不会改变原图的色调。如果我们要增加绿色的值，我们就可以修改 <strong>add</strong> 的值为 <strong>0x0000XX00</strong>(其中 <strong>xx</strong> 介于 <strong>00-FF</strong> 之间);如果我们要去掉绿色的值,我们就可以修改 <strong>mul</strong> 中 <strong>xx</strong> 的值。总之，去掉某个颜色修改 <strong>mul</strong> 值，增加某个颜色值修改 <strong>add</strong>。<br>例子:  </p>
<pre><code>    LightingColorFilter filter1=new LightingColorFilter(0xFFFFFFFF,0x00000000);
    LightingColorFilter filter2=new LightingColorFilter(0xFFFF00FF,0x00000000);
    LightingColorFilter filter3=new LightingColorFilter(0xFFFFFFFF,0x0000FF00);
    Bitmap panda= BitmapFactory.decodeResource(getResources(), R.drawable.images);
    mPaint.setColorFilter(filter1);
    canvas.drawBitmap(panda,20,20,mPaint);
    mPaint.reset();
    mPaint.setColorFilter(filter2);
    canvas.drawBitmap(panda,20,25+panda.getHeight(),mPaint);
    mPaint.reset();
    mPaint.setColorFilter(filter3);
    canvas.drawBitmap(panda,20,30+panda.getHeight()*2,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhn800mll5j20bc0j7gt9.jpg" alt="">  </p>
<ol>
<li><strong>ColorMatrixColorFilter</strong><br>作用：通过 <strong>4*5</strong> 颜色矩阵来改善中像素的饱满度  </li>
</ol>
<p>构造方法1:</p>
<pre><code>ColorMatrixColorFilter(ColorMatrix matrix)
</code></pre><p><strong>ColorMatrix</strong> 可改变 <strong>bitmap</strong> 上的颜色和透明度（变换 <strong>RGBA</strong> 的值，达到改变的目的）,可以以一组 <strong>4*5</strong> 的数组构建该对象<br>构造方法2:</p>
<pre><code>ColorMatrixColorFilter (float[] array)  
</code></pre><p>假设颜色矩阵为  </p>
<pre><code>    [ a, b, c, d, e,  
    f, g, h, i, j,  
    k, l, m, n, o,  
    p, q, r, s, t ]   
</code></pre><p>则计算公式为:  </p>
<pre><code>   R’ = a*R + b*G + c*B + d*A + e;  
   G’ = f*R + g*G + h*B + i*A + j;  
   B’ = k*R + l*G + m*B + n*A + o;  
   A’ = p*R + q*G + r*B + s*A + t;   
</code></pre><p>由矩阵相乘的原理可知，任何一个矩阵与单位矩阵相乘仍为本身(不懂去补矩阵基础知识)。那么现在类比 <strong>LightingColorFilter</strong> 的计算公式，你是否发现了点什么？没错，颜色矩阵的前 <strong>4</strong> 列(<strong>必须按顺序</strong>)采用的值产生效果与颜色倍增一致，而最后一列与颜色增加的效果一致, 接下来我们修改颜色矩阵，使之和上图中的效果一致。<br>例子：  </p>
<pre><code>    ColorMatrixColorFilter filter1 = new ColorMatrixColorFilter(new float[]{
            1, 0, 0, 0, 0,
            0, 1, 0, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 0, 1, 0
    });
    ColorMatrixColorFilter filter2 = new ColorMatrixColorFilter(new float[]{
            1, 0, 0, 0, 0,
            0, 0, 0, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 0, 1, 0
    });
    ColorMatrixColorFilter filter3 = new ColorMatrixColorFilter(new float[]{
            1, 0, 0, 0, 0,
            0, 1, 0, 0, 255,
            0, 0, 1, 0, 0,
            0, 0, 0, 1, 0
    });  
</code></pre><ol>
<li><p><strong>PorterDuffColorFilter</strong><br>作用：通过使用单颜色或 <strong>Porter-Duff</strong> 组合模式来为源像素着色<br>实例：  </p>
<p> setColorFilter(Color.parseColor(“#99000000”), PorterDuff.Mode.DARKEN);<br> 可设置ImageView的前景色为透明黑<br>构造方法:</p>
<p> PorterDuffColorFilter(int color, PorterDuff.Mode mode)<br>对参数的解释:  </p>
</li>
</ol>
<ul>
<li><strong>color</strong>:<strong>16</strong> 进制 <strong>ARGB</strong> 值</li>
<li><strong>mode</strong>:指定的 <strong>PorterDuff.Mode</strong>(<strong>这里主要是图像色彩混和</strong>)。共有 <strong>5</strong> 种，分别是<strong>Darken(变暗)、Lighten(变亮)、Multiply(正片叠底)、Overlay(重叠)、Screen(滤色)</strong>，预知各种模式详解请耐心继续往下看。  </li>
</ul>
<p>例子:  </p>
<pre><code>    PorterDuffColorFilter filter1=new PorterDuffColorFilter(0xFFFF0000, PorterDuff.Mode.DARKEN);
    PorterDuffColorFilter filter2=new PorterDuffColorFilter(0xFFFF0000, PorterDuff.Mode.MULTIPLY);
    PorterDuffColorFilter filter3=new PorterDuffColorFilter(0xFFFF0000, PorterDuff.Mode.SCREEN);
    PorterDuffColorFilter filter4=new PorterDuffColorFilter(0xFFFF0000, PorterDuff.Mode.LIGHTEN);
    PorterDuffColorFilter filter5=new PorterDuffColorFilter(0xFFFF0000, PorterDuff.Mode.OVERLAY);
    Bitmap panda= BitmapFactory.decodeResource(getResources(), R.drawable.images);
    mPaint.setColorFilter(filter1);
    canvas.drawBitmap(panda,20,10,mPaint);
    mPaint.setColorFilter(filter2);
    canvas.drawBitmap(panda,20,15+panda.getHeight(),mPaint);
    mPaint.setColorFilter(filter3);
    canvas.drawBitmap(panda,20,20+panda.getHeight()*2,mPaint);
    mPaint.setColorFilter(filter4);
    canvas.drawBitmap(panda,20,25+panda.getHeight()*3,mPaint);
    mPaint.setColorFilter(filter5);
    canvas.drawBitmap(panda,20,30+panda.getHeight()*4,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhn9esio0sj20ay0qjn5v.jpg" alt=""></p>
<h2 id="mPaint-setDither"><a href="#mPaint-setDither" class="headerlink" title="mPaint.setDither"></a>mPaint.setDither</h2><p>方法：</p>
<pre><code>void setDither (boolean dither)  
</code></pre><p>作用：设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰。其实当下智能手机也有运动防抖功能，只要你用过一定知道区别。</p>
<h2 id="mPaint-setFakeBoldText"><a href="#mPaint-setFakeBoldText" class="headerlink" title="mPaint.setFakeBoldText"></a>mPaint.setFakeBoldText</h2><p>方法:</p>
<pre><code>void setFakeBoldText (boolean fakeBoldText)     
</code></pre><p>设置伪粗体文本,与设置 <strong>FAKE_BOLD_TEXT_FLAG</strong> 一样,只是一种文本显示效果而已，咱不深究。  </p>
<h2 id="mPaint-setFilterBitmap"><a href="#mPaint-setFilterBitmap" class="headerlink" title="mPaint.setFilterBitmap"></a>mPaint.setFilterBitmap</h2><p>方法:</p>
<pre><code>void setFilterBitmap (boolean filter)    
</code></pre><p>设置位图进行<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2" target="_blank" rel="noopener">滤波</a>(<strong>Filter</strong>)处理  </p>
<h2 id="mPaint-setHinting"><a href="#mPaint-setHinting" class="headerlink" title="mPaint.setHinting"></a>mPaint.setHinting</h2><p>方法：</p>
<pre><code>void setHinting (int mode)  
</code></pre><p> 设置字体微调, 可以是 <strong>HINTING_OFF or HINTING_ON</strong>. 由于当今手机密度高，此方法已无用武之地，略过。</p>
<h2 id="mPaint-setLetterSpacing"><a href="#mPaint-setLetterSpacing" class="headerlink" title="mPaint.setLetterSpacing"></a>mPaint.setLetterSpacing</h2><p>方法:</p>
<pre><code>void setLetterSpacing (float letterSpacing)     
</code></pre><p>设置文本的字符间距，默认值为0，负数值会缩紧文本。注意文字本身两侧默认有间隙  </p>
<h2 id="mPaint-setLinearText"><a href="#mPaint-setLinearText" class="headerlink" title="mPaint.setLinearText"></a>mPaint.setLinearText</h2><p>方法:</p>
<pre><code>void setLinearText (boolean linearText)  
</code></pre><p>设置文本为线性排列  </p>
<h2 id="mPaint-setMaskFilter"><a href="#mPaint-setMaskFilter" class="headerlink" title="mPaint.setMaskFilter"></a>mPaint.setMaskFilter</h2><ol>
<li><p>方法: </p>
<pre><code> MaskFilter setMaskFilter (MaskFilter maskfilter)   
</code></pre><p>设置或清除滤镜效果,传入 <strong>null</strong> 可清除之前的滤镜效果,<strong>maskfilter</strong> 由两个子类  <strong>BlurMaskFilter</strong>、<strong>EmbossMaskFilter</strong>所构造.</p>
</li>
<li><p><strong>BlurMaskFilter</strong> 模糊滤镜<br>构造方法:</p>
<pre><code> BlurMaskFilter(float radius, BlurMaskFilter.Blur style)    
</code></pre><p>对参数的解释:  </p>
<ul>
<li><strong>radius</strong>:设置显示的阴影半径,必须大于<strong>0</strong>  </li>
<li><strong>style</strong>:待应用的阴影模式  </li>
<li><strong>INNER</strong>:绘制内阴影和图片内容本身，不绘制外阴影</li>
<li><strong>NORMAL</strong>:正常阴影效果</li>
<li><strong>OUTER</strong>:不绘制内部阴影及图片内容，只绘制外阴影</li>
<li><strong>SOLID</strong>:只绘制外部阴影和图片内容，不绘制内阴影，与 <strong>INNER</strong> 相对  </li>
</ul>
</li>
<li><p><strong>EmbossMaskFilter</strong> 浮雕滤镜<br>构造方法:</p>
<pre><code>EmbossMaskFilter(float[] direction, float ambient, float specular, float blurRadius)    
</code></pre><p>对参数的解释:  </p>
<ul>
<li><strong>direction</strong>:指定光源的方向，由3个量构成的[x,y,z]设置 </li>
<li><strong>ambient</strong>:背景光的亮度，取值区间[0,1],决定背景的明暗程度</li>
<li><strong>specular</strong>:高光系数,值越小反射越强,那么亮度也相对偏亮</li>
<li><strong>blurRadius</strong>:阴影延伸半径  </li>
</ul>
</li>
<li><p>例子:  </p>
<pre><code> mPaint.setMaskFilter(new BlurMaskFilter(5, BlurMaskFilter.Blur.NORMAL));
 mPaint.setMaskFilter(new EmbossMaskFilter(new float[]{1,1,1},0.5f,8f,3f));  
</code></pre></li>
</ol>
<ul>
<li><strong>BlurMaskFilter.Blur.NORMAL</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhoe7ni5t5j20ax080q66.jpg" alt="">  </li>
<li><strong>BlurMaskFilter.Blur.INNER</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhoeapo9rqj20ar08j0vy.jpg" alt="">  </li>
<li><strong>BlurMaskFilter.Blur.OUTER</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhoeby4g1gj20b708gadb.jpg" alt="">  </li>
<li><strong>BlurMaskFilter.Blur.SOLID</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhoedtl4a3j20ba08iwhq.jpg" alt="">  </li>
<li>浮雕滤镜效果(可自个手动调值，感受下效果差异)<br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhoenuv7gdj20az08stby.jpg" alt=""></li>
</ul>
<h2 id="mPaint-setPathEffect"><a href="#mPaint-setPathEffect" class="headerlink" title="mPaint.setPathEffect"></a>mPaint.setPathEffect</h2><ol>
<li><p>方法:</p>
<pre><code> PathEffect setPathEffect (PathEffect effect)  
</code></pre><p>设置或清除路径效果，传入 <strong>null</strong>清除效果<br><strong>PathEffect</strong> 共有 <strong>6</strong> 个子类可用于构造对象，然后作为方法参数传入  </p>
</li>
<li><p><strong>CornerPathEffect</strong><br>构造方法:</p>
<pre><code> CornerPathEffect (float radius)
</code></pre><p>改变线段之间的圆滑度，而不是带锐角的折线形式<br>对参数的解释:  </p>
<ul>
<li><strong>radius</strong>:线段之间的圆滑程度    </li>
</ul>
</li>
<li><p><strong>DashPathEffect</strong><br>构造方法:</p>
<pre><code>DashPathEffect (float[] intervals, float phase)   
</code></pre><p>设置路径的虚线效果,<strong>setStroke</strong> 控制虚线的厚薄度<br>对参数的解释:  </p>
<ul>
<li><strong>interval</strong>:间隔数组，控制虚线的长度,其中第一个偶数指数即 <strong>0</strong> 所对应的值(至少为 <strong>2</strong> )表示第一条实线的长度，第一个奇数指数即 <strong>1</strong> 所对应的值表示第一条虚线的长度,第二个偶数对应实线，第二个奇数对应虚线…以此类推。数组不再由新元素，则开始从第一个数循环。  </li>
<li><strong>phase</strong>: 虚实线间的间距。  </li>
</ul>
<p>此类妙用:  当虚实线的长度为整个 <strong>path</strong> 的长度时，即 <strong>intervals</strong> 数组中仅有两个相等的元素且均为 <strong>path</strong> 长度时,虚实线的间距为 <strong>0</strong>,绘制出来的效果就是一条完整的实线。而虚实线的间距如果为 <strong>0</strong>到 <strong>path</strong> 长度之间动态变化（可借助值动画动态得到<strong>【0，1】</strong>之间变化的比例），那么就会出现类似沿着路径绘制的动画效果。</p>
</li>
<li><p><strong>DiscretePathEffect</strong><br>构造方法：</p>
<pre><code> DiscretePathEffect (float segmentLength, float deviation)  
</code></pre><p>设置离散的路径效果<br>对参数的解释:  </p>
<ul>
<li><strong>segmentLength</strong> :离散片段的长度</li>
<li><strong>deviation</strong>： 随机的偏移原路径的值    </li>
</ul>
</li>
<li><p><strong>PathDashPathEffect</strong><br>构造方法:</p>
<pre><code> PathDashPathEffect (Path shape, float advance, float phase, PathDashPathEffect.Style style)  
</code></pre><p>用指定的路径形状对所画的路径进行虚线化标记,<strong>与顺序有关</strong>。<br>对参数的理解:  </p>
<ul>
<li><strong>shape</strong>:虚线段的路径形状  </li>
<li><strong>advance</strong>:实线的间隔，即长度</li>
<li><strong>phase</strong>:虚实线间的间距  </li>
<li><strong>style</strong>:由 <strong>NOMAL,ROTATE,TRANSLATES</strong> 三种样式    </li>
</ul>
</li>
<li><p><strong>SumPathEffect</strong><br>构造方法：</p>
<pre><code> SumPathEffect(PathEffect first, PathEffect second)  
</code></pre><p>逐一组合路径效果，<strong>与顺序无关</strong>。<br>对参数的理解:  </p>
<ul>
<li><strong>first</strong>:第一个路径效果  </li>
<li><strong>second</strong>: 第二个路径效果  </li>
</ul>
</li>
<li><p><strong>ComposePathEffect</strong><br>构造方法:</p>
<pre><code> ComposePathEffect (PathEffect outerpe, PathEffect innerpe)  
</code></pre><p>先指定一个内部路径效果，再指定一个外部路径效果，再将二者组合形成新的路径效果。  </p>
</li>
<li><p>例子:  </p>
<pre><code> public class DrawPractice extends View {
 private Paint mPaint = new Paint();
 public static final String TAG = &quot;DrawPractice&quot;;
 private PathEffect[] mPathEffects = new PathEffect[9];
 private  Path path;

 //省略构造函数
 private void init() {
     mPaint.setColor(Color.BLUE);
     mPaint.setAntiAlias(true);
     mPaint.setStyle(Paint.Style.STROKE);
     mPaint.setStrokeWidth(5);
     initPath();
 }

 private void initPath() {
 path = new Path();
 path.moveTo(20, 50);//路线起点

 for (int i = 0; i &lt;= 30; i++) {//随机生成折线
     path.lineTo(i * 35, (float) (Math.random() * 100));
 }
     mPathEffects[0]=null;
     mPathEffects[1]=new CornerPathEffect(5);
     mPathEffects[2]=new DashPathEffect(new float[]{20,10,5,1},5);
     mPathEffects[3]=new DiscretePathEffect(10,5);
     Path mPath=new Path();
     mPath.addRect(0,0,10,10, Path.Direction.CCW);
     mPathEffects[4]=new PathDashPathEffect(mPath,20,5f,PathDashPathEffect.Style.ROTATE);
      //注意5，6的区别 详细看图
     mPathEffects[5]=new ComposePathEffect(mPathEffects[1],mPathEffects[4]);
     mPathEffects[6]=new ComposePathEffect(mPathEffects[4],mPathEffects[1]);
     //7,8其实没区别  详细看图
     mPathEffects[7]=new SumPathEffect(mPathEffects[1],mPathEffects[4]);
     mPathEffects[8]=new SumPathEffect(mPathEffects[4],mPathEffects[1]);
 }

 @Override
 protected void onDraw(Canvas canvas) {
     super.onDraw(canvas);
 for (int i = 0; i &lt;mPathEffects.length ; i++) {
     mPaint.setPathEffect(mPathEffects[i]);
     canvas.drawPath(path,mPaint);
     canvas.translate(0,100);
     }
 }
 }  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhogedferpj20fe0gr0ul.jpg" alt="">  </p>
</li>
</ol>
<h2 id="mPaint-setShader"><a href="#mPaint-setShader" class="headerlink" title="mPaint.setShader"></a>mPaint.setShader</h2><ol>
<li><p>方法:</p>
<pre><code> Shader setShader (Shader shader)    
</code></pre><p>设置着色器,传入<strong>null</strong>清除<br>对参数的解释:  </p>
<ul>
<li><strong>shader</strong>:由 <strong>Shader</strong> 的五个子类构造传入,下面介绍。  </li>
</ul>
</li>
<li><p><strong>BitmapShader</strong><br>构造方法:</p>
<pre><code>     BitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY)    
</code></pre><p>作用:渲染位图<br>对参数的解释:  </p>
<ul>
<li><strong>bitmap</strong>: 位图  </li>
<li><strong>tileX</strong>:水平方向的一种模式</li>
<li><strong>tileY</strong>:竖直方向的一种模式<br>三种模式:    </li>
<li><strong>Shader.TileMode.CLAMP</strong>:重复水平或者竖直方向上位图的边缘颜色  </li>
<li><strong>Shader.TileMode.MIRROR</strong>:水平或者竖直方向上重复图片的镜像，并且连接处看似无缝对接  </li>
<li><p><strong>Shader.TileMode.REPEAT</strong>:水平或者竖直方向上重复图片<br>例子:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  Bitmap panda = BitmapFactory.decodeResource(getResources(), R.drawable.images);
  mPaint.setShader(new BitmapShader(panda, Shader.TileMode.CLAMP, Shader.TileMode.REPEAT));
  canvas.drawCircle(300,300,300,mPaint);
  mPaint.setShader(new BitmapShader(panda, Shader.TileMode.MIRROR, Shader.TileMode.REPEAT));
  canvas.drawCircle(300,900,300,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhqm0vzgfsj20eh0qfk6r.jpg" alt="">  </p>
</li>
</ul>
</li>
<li><p><strong>LinearGradient</strong><br>作用:设置一个沿着直线的线性渐变效果<br>构造方法1:</p>
<pre><code>     LinearGradient (float x0, 
             float y0, 
             float x1, 
             float y1, 
             int[] colors, 
             float[] positions, 
             Shader.TileMode tile)    
</code></pre><p>对参数的解释:    </p>
<ul>
<li><strong>x0,y0,x1,y1</strong>:渐变直线的起点和终点  </li>
<li><strong>colors</strong>:用于产生渐变效果的颜色组,非空 ，至少两种颜色</li>
<li><strong>positions</strong>:可为空,控制颜色数组不均匀的渐变，取值[0..1] </li>
<li><strong>tile</strong>:仍旧有三种模式可设置见上<br>构造方法2：<pre><code>  LinearGradient(float x0, float y0, float x1, float y1, int color0, int color1, Shader.TileMode tile)  
</code></pre>对参数的解释:  </li>
<li><strong>color0</strong>:渐变的起始颜色</li>
<li><p><strong>color1</strong>:渐变的终止颜色<br>例子:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(10);
  mPaint.setShader(new LinearGradient(0,0,500,500, 
                  new int[]{R.color.colorPrimaryDark, Color.BLUE},null,Shader.TileMode.CLAMP));
  canvas.drawRect(new RectF(20,20,200,200),mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhqmatix89j208409cq2s.jpg" alt="">  </p>
</li>
</ul>
</li>
<li><p><strong>RadialGradient</strong><br>作用:产生辐射状的渐变效果<br>构造方法1: </p>
<pre><code>     RadialGradient (float centerX, 
             float centerY, 
             float radius, 
             int[] colors, 
             float[] stops, 
             Shader.TileMode tileMode)    
</code></pre><p>对参数的解释：  </p>
<ul>
<li><strong>centerX,centerY</strong>:辐射的中心坐标</li>
<li><strong>radius</strong>:辐射半径</li>
<li><strong>colors</strong>:渐变颜色数组，至少两种颜色</li>
<li><strong>stops</strong>:可为空,控制颜色数组不均匀的渐变，取值[0..1]<br>构造方法2:  <pre><code>  RadialGradient (float centerX, 
          float centerY, 
          float radius, 
          int centerColor, 
          int edgeColor, 
          Shader.TileMode tileMode)    
</code></pre>对参数的解释:  </li>
<li><strong>centerColor</strong>: 辐射中心的颜色  </li>
<li><p><strong>edgeColor</strong>:辐射边缘的颜色<br>例子:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setShader(new RadialGradient(300,300,300, Color.RED, Color.BLUE,Shader.TileMode.CLAMP));
  canvas.drawCircle(200,300,200,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhqmf8oa30j20ac0d8myi.jpg" alt="">  </p>
</li>
</ul>
</li>
<li><p><strong>SweepGradient</strong><br>作用:绕中心顺时针旋转360度渐变<br>构造方法1: </p>
<pre><code>     SweepGradient (float cx, 
             float cy, 
             int[] colors, 
             float[] positions)    
</code></pre><p>对参数的解释：  </p>
<ul>
<li><strong>cx,cy</strong>: 旋转中心坐标</li>
<li><strong>colors</strong>:渐变颜色数组，至少两种颜色</li>
<li><strong>positions</strong>:可为空,控制颜色数组不均匀的渐变，取值[0..1]<br>构造方法2:  <pre><code>  SweepGradient (float cx, 
          float cy, 
          int color0, 
          int color1)    
</code></pre>对参数的解释:  </li>
<li><strong>color0</strong>: 渐变的起始颜色 </li>
<li><p><strong>color1</strong>:渐变的终止颜色<br>例子:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setShader(new SweepGradient(300,300 ,Color.RED, Color.BLUE));
  canvas.drawCircle(200,300,200,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhqmgoged8j20al0dg0tz.jpg" alt="">  </p>
</li>
</ul>
</li>
<li><p><strong>ComposeShader</strong><br>作用:用指定的模式组合两个渐变效果<br>构造方法1: </p>
<pre><code>     ComposeShader (Shader shaderA, 
             Shader shaderB, 
             Xfermode mode)    
</code></pre><p>对参数的解释：  </p>
<ul>
<li><strong>shaderA,shaderB</strong>: 要组合的两个渐变 <strong>shader</strong>  </li>
<li><strong>Xfermode mode</strong>:设置两张图片相交时的混合模式，与<strong>mPaint.setXfermode()</strong>一样<br>构造方法2:  <pre><code>      ComposeShader (Shader shaderA, 
          Shader shaderB, 
          PorterDuff.Mode mode)  
</code></pre>对参数的解释:  </li>
<li><p><strong>PorterDuff.Mode mode</strong>:设置两张图片相交时的混合规则<br>例子：  </p>
<pre><code>  BitmapShader shader = new BitmapShader(BitmapFactory.decodeResource(getResources(), R.drawable.images), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
  BitmapShader shader1 = new BitmapShader(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
  mPaint.setShader(new ComposeShader(shader, shader1, PorterDuff.Mode.SRC_OVER));
  canvas.drawCircle(50, 50, 50, mPaint);    
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhrvcznt4oj207y07vgln.jpg" alt="">    </p>
</li>
</ul>
</li>
</ol>
<p><strong>PorterDuffXfermode</strong>(<strong>XferMode</strong> 子类)<br>构造方法: </p>
<pre><code>    PorterDuffXfermode(PorterDuff.Mode mode)  
</code></pre><p>作用：指定一个 <strong>PorterDuff</strong>规则创建Xfermode实例<br><a href="http://www.jianshu.com/p/d11892bbe055" target="_blank" rel="noopener">PorterDuff.Mode使用详解看这</a></p>
<h2 id="mPaint-setShaderLayer"><a href="#mPaint-setShaderLayer" class="headerlink" title="mPaint.setShaderLayer"></a>mPaint.setShaderLayer</h2><ol>
<li><p>方法:  </p>
<pre><code> void setShadowLayer (float radius, float dx, float dy, int shadowColor)
</code></pre><p>作用:在主图层下添加阴影效果<br>对参数的解释:  </p>
<ul>
<li><strong>radius</strong>:设置显示阴影的半径</li>
<li><strong>dx,dy</strong>:基准点</li>
<li><strong>shadowColor</strong>:用于生成阴影的颜色<br>注意点：为文字加阴影不需要关闭硬件加速，否则都需要开启，方可显示效果。</li>
</ul>
</li>
<li><p>例子：  </p>
<pre><code> mPaint.setColor(Color.BLUE);
 mPaint.setTextSize(20);
 mPaint.setShadowLayer(50,50,50, Color.RED);
 canvas.drawText(&quot;看主图层下面的阴影效果&quot;,50,50,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhrvkk5fmzj209907ua9z.jpg" alt="">  </p>
</li>
</ol>
<h2 id="mPaint-setStrikeThruText"><a href="#mPaint-setStrikeThruText" class="headerlink" title="mPaint.setStrikeThruText"></a>mPaint.setStrikeThruText</h2><ol>
<li><p>方法:  </p>
<pre><code> void setStrikeThruText (boolean strikeThruText)
</code></pre></li>
<li>作用:设置删除线,与 <strong>setFlag(STRIKE_THRU_TEXT_FLAG)</strong>同等效果<br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhruzmonnjj206t06xa9y.jpg" alt="">  </li>
</ol>
<h2 id="mPaint-setStrokeCap"><a href="#mPaint-setStrokeCap" class="headerlink" title="mPaint.setStrokeCap"></a>mPaint.setStrokeCap</h2><ol>
<li><p>方法:  </p>
<pre><code> void setStrokeCap (Paint.Cap cap)  
</code></pre></li>
<li>作用：当画笔的样式是 <strong>Stroke</strong> 或者 <strong>StrokeAndFill</strong>，可改变画笔的笔头样式，比如圆形的笔头(<strong>Cap.ROUND</strong>)、方形的笔头(<strong>Cap.SQUARE</strong>)  </li>
<li>例子:<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhqrwi1ljlj208r0a0dfn.jpg" alt=""><br>从左到右分别为 <strong>BUTT(默认)、ROUND、SQUARE</strong>。其中后两条线前后均会超出上下的基线，并且形状各异，很像戴了个帽子(<strong>Cap</strong>)。</li>
</ol>
<h2 id="mPaint-setStrokeJoin"><a href="#mPaint-setStrokeJoin" class="headerlink" title="mPaint.setStrokeJoin"></a>mPaint.setStrokeJoin</h2><ol>
<li><p>方法:  </p>
<pre><code> void setStrokeJoin (Paint.Join join)  
</code></pre><p>作用:当画笔的样式是 <strong>Stroke</strong> 或者 <strong>StrokeAndFill</strong>,可改变画笔在转弯时候的样式,锐角、斜切、圆角处理。 </p>
</li>
<li>例子:<br><a href="http://blog.csdn.net/hnulwt/article/details/42705895" target="_blank" rel="noopener">Cap 与 Join 详解</a><br>从左到右分别是 <strong>MITER,BEVEL,ROUND;</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhqrk7lvhxj20de088glf.jpg" alt="">  </li>
</ol>
<h2 id="mPaint-setStrokeMiter"><a href="#mPaint-setStrokeMiter" class="headerlink" title="mPaint.setStrokeMiter"></a>mPaint.setStrokeMiter</h2><ol>
<li><p>方法:  </p>
<pre><code> void setStrokeMiter (float miter)  
</code></pre></li>
<li>作用：当画笔的样式是 <strong>Stroke</strong> 或者 <strong>StrokeAndFill</strong>,控制斜接连接处的角度，值必须大于等于 <strong>0</strong>，即控制Paint.Join.Miter的效果</li>
</ol>
<h2 id="mPaint-setStrokeWidth"><a href="#mPaint-setStrokeWidth" class="headerlink" title="mPaint.setStrokeWidth"></a>mPaint.setStrokeWidth</h2><ol>
<li><p>方法:  </p>
<pre><code> void setStrokeWidth (float width)  
</code></pre></li>
<li>作用:设置画笔的粗细程度    </li>
</ol>
<h2 id="mPaint-setStyle"><a href="#mPaint-setStyle" class="headerlink" title="mPaint.setStyle"></a>mPaint.setStyle</h2><ol>
<li><p>方法:  </p>
<pre><code> void setStyle (Paint.Style style)  
</code></pre></li>
<li>作用:控制画笔的样式模式,有仅填充(<strong>Paint.Style.Fill</strong>),描边且填充(<strong>Paint.Style.FILL_AND_STROKE</strong>),仅描边(<strong>Paint.Style.STROKE</strong>),简单地说，就是空心还是实心。  </li>
</ol>
<h2 id="mPaint-setSubpixelText"><a href="#mPaint-setSubpixelText" class="headerlink" title="mPaint.setSubpixelText"></a>mPaint.setSubpixelText</h2><ol>
<li><p>方法:  </p>
<pre><code> void setSubpixelText (boolean subpixelText)  
</code></pre></li>
<li>作用:有助于文本在LCD屏幕上的显示效果.但由于当今手机密度高,此方法已无用武之地,略过。  </li>
</ol>
<h2 id="mPaint-setTextAlign"><a href="#mPaint-setTextAlign" class="headerlink" title="mPaint.setTextAlign"></a>mPaint.setTextAlign</h2><ol>
<li><p>方法:  </p>
<pre><code> void setTextAlign (Paint.Align align)  
</code></pre><p>作用：设置文本的对齐方式,以有文本第一个字为基准靠左(<strong>Paint.Align.LEFT</strong>),居中(<strong>Paint.Align.CENTER</strong>),以文本最后一个字为基准靠右(<strong>Paint.Align.RIGHT</strong>)。  </p>
</li>
<li>例子:  </li>
</ol>
<h2 id="mPaint-setTextLocale"><a href="#mPaint-setTextLocale" class="headerlink" title="mPaint.setTextLocale"></a>mPaint.setTextLocale</h2><ol>
<li><p>方法：  </p>
<pre><code> void setTextLocale (Locale locale)  
</code></pre></li>
<li><p>作用：指定字体所使用的语言,例如<strong>Local.CHINA</strong>  </p>
</li>
</ol>
<h2 id="mPaint-setTextScaleX"><a href="#mPaint-setTextScaleX" class="headerlink" title="mPaint.setTextScaleX"></a>mPaint.setTextScaleX</h2><ol>
<li><p>方法：  </p>
<pre><code> void setTextScaleX (float scaleX)  
</code></pre></li>
<li>作用:设置文本的缩放比，默认为 <strong>1</strong>.值大于 <strong>1</strong>文本变宽，值小于 <strong>1</strong> 值变窄   </li>
<li>例子:  </li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhruojcqu2j20a308yt8u.jpg" alt=""></p>
<h2 id="mPaint-setTextSize"><a href="#mPaint-setTextSize" class="headerlink" title="mPaint.setTextSize"></a>mPaint.setTextSize</h2><ol>
<li><p>方法:  </p>
<pre><code> void setTextSize (float textSize)  
</code></pre></li>
<li>作用:设置文本的字体大小  </li>
</ol>
<h2 id="mPaint-setTextSkewX"><a href="#mPaint-setTextSkewX" class="headerlink" title="mPaint.setTextSkewX"></a>mPaint.setTextSkewX</h2><ol>
<li><p>方法：  </p>
<pre><code> void setTextSkewX (float skewX)  
</code></pre></li>
<li>作用:设置文本的斜切比(也叫文字的倾斜度),默认为 <strong>0</strong>，若要使用合适的倾斜文本，推荐使用 <strong>-0.25</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhrurhu6t3j207w08fmx6.jpg" alt="">  </li>
</ol>
<h2 id="mPaint-setTypeface"><a href="#mPaint-setTypeface" class="headerlink" title="mPaint.setTypeface"></a>mPaint.setTypeface</h2><ol>
<li><p>方法:  </p>
<pre><code> Typeface setTypeface (Typeface typeface)  
</code></pre></li>
<li>作用:设置文本的字体，传入 <strong>null</strong> 清除字体。<strong>Typeface</strong> 包含了字体的类型，粗细，还有倾斜、颜色等。    </li>
</ol>
<h2 id="mPaint-setUnderlineText"><a href="#mPaint-setUnderlineText" class="headerlink" title="mPaint.setUnderlineText"></a>mPaint.setUnderlineText</h2><ol>
<li><p>方法：  </p>
<pre><code> void setUnderlineText (boolean underlineText)  
</code></pre></li>
<li>作用:设置下划线<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhrutchzj3j207k08a746.jpg" alt="">  </li>
</ol>
<h1 id="getxx及其他方法"><a href="#getxx及其他方法" class="headerlink" title="getxx及其他方法"></a>getxx及其他方法</h1><h2 id="mpaint-getFontSpace"><a href="#mpaint-getFontSpace" class="headerlink" title="mpaint.getFontSpace"></a>mpaint.getFontSpace</h2><ol>
<li><p>方法:  </p>
<pre><code> float getFontSpacing () 
</code></pre><p>作用：返回基于当前文字大小和字体所推荐的一个行间距。在绘制多行文本的时候可以通过此方法更改文字的下一基线位置,使得两行文本之间的间距达到一个合适的值。  </p>
</li>
<li><p>例子:  </p>
<pre><code> String text = &quot;使用 drawText() 来绘制文字&quot;;
 canvas.drawText(text, 50, 100, paint);
 canvas.drawText(text, 50, 100 + paint.getFontSpacing(), paint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fi1xf7fkm2j20bv084dg3.jpg" alt="">  </p>
</li>
</ol>
<h2 id="mpaint-getFontMetric"><a href="#mpaint-getFontMetric" class="headerlink" title="mpaint.getFontMetric"></a>mpaint.getFontMetric</h2><ol>
<li><p>方法1:  </p>
<pre><code> Paint.FontMetrics getFontMetrics ()  
</code></pre></li>
<li><p>方法2：  </p>
<pre><code> float getFontMetrics (Paint.FontMetrics metrics)  
</code></pre></li>
<li>详解:<strong>FontMetricsInt</strong>共有 <strong>5</strong> 个值，分别是 <strong>top、bottom、ascent、descent、leading</strong><br><strong>top</strong> 与 <strong>bottom</strong> 限制了文字绘制的最大和最小的范围。<strong>ascent</strong> 和 <strong>descent</strong> 限制了字形的所有顶部与底部的范围（不同的字形有高低，有的顶高一些，有的底低一些),<strong>leading</strong> 表示两行文字各自的基线之间的间距<br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fi21sj2fd2j20oe06jwg6.jpg" alt=""><br>此图来源于扔物线大佬的杰作。<br>由图中按顺序，分别时 <strong>top、ascent、baseline、 descent、bottom</strong> 所在的直线。<br>并且以 <strong>baseline</strong> 为轴，在其上的线所在位置为负数距离，在其下的线所在的位置为正数距离。<br>例如:<code>fontMetric.bottom-fonMetric.top</code>即表示文字上下区域的一个最大高度。<br>另外，如果需要多次调用方法 <strong>1</strong>，那么可以选择使用方法 <strong>2</strong> 以提高性能。<br>注意:如果要使绘制的多个文本 <strong>baseline</strong> 对齐，可以使用<strong>int middle = (top + bottom) / 2;</strong><br>计算法来控制文本同在一条基线上。  </li>
</ol>
<h2 id="paint-getTextBound"><a href="#paint-getTextBound" class="headerlink" title="paint.getTextBound"></a>paint.getTextBound</h2><ol>
<li><p>方法1:  </p>
<pre><code> void getTextBounds (String text, int start, int end, Rect bounds)  
</code></pre></li>
<li><p>方法2:  </p>
<pre><code> void getTextBounds (char[] text,  int index, int count, Rect bounds)  
</code></pre></li>
<li>作用：返回文字四周的显示范围 </li>
<li>参数 <strong>bound</strong> 为一个矩形对象。当方法完成测量后会将值返回给该对象，进而得到一个矩形范围。如果矩形的四个坐标再加上一定偏移值则刚好可以将文字包围住。  </li>
<li><p>例子:  </p>
<pre><code> String text = &quot;绘制文字&quot;;
 paint.setStyle(Paint.Style.FILL);
 int offsetX = 50, offsetY = 100;
 canvas.drawText(text, offsetX, offsetY, paint);
 Rect bounds = new Rect();
 paint.getTextBounds(text, 0, text.length(), bounds);
 bounds.left += offsetX;
 bounds.top += offsetY;
 bounds.right += offsetX;
 bounds.bottom += offsetY;
 paint.setStyle(Paint.Style.STROKE);
 canvas.drawRect(bounds, paint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fi1yr1tk1gj208b059glg.jpg" alt=""><br><strong>注意</strong>：此方法测量出来的值会比 <strong>measureText()</strong> 更少一些，原因在于 <strong>measuresText</strong> 方法测量的是文字所占用的宽度，而者宽度还包括类文字两边默认的一个间隙。</p>
</li>
</ol>
<h2 id="mPaint-setXfermode"><a href="#mPaint-setXfermode" class="headerlink" title="mPaint.setXfermode"></a>mPaint.setXfermode</h2><ol>
<li><p>方法:  </p>
<pre><code> Xfermode setXfermode (Xfermode xfermode)  
</code></pre><p>作用：设置图像混合模式，其实是使用 <strong>Xfermode</strong>的子类 <strong>PorterDuffXfermode</strong>,而整个子类又是由 <strong>PorterDuff.Mode</strong>来决定的。</p>
</li>
</ol>
<h2 id="PorterDuff-Mode的详解"><a href="#PorterDuff-Mode的详解" class="headerlink" title="PorterDuff.Mode的详解"></a>PorterDuff.Mode的详解</h2><ol>
<li>名称由来：该种图像组合模式时由分别叫 <strong>Porter</strong> 和 <strong>Duff</strong> 两人提出的，因此为了表示对他们的敬意，便以二人的名称合体来命名这种模式。其实他们仅提出了12种<a href="https://en.wikipedia.org/wiki/Alpha_compositing" target="_blank" rel="noopener">Alpha合成模式</a>，后来为了方便便将图像混合的模式也加入到该类中。  </li>
<li>作用:用于图形合成时图像的饱和度、颜色值等的图像表现。</li>
<li>关键的两个图像:原图像(<strong>Source image</strong>)和目标图像(<strong>Destination image</strong>)  </li>
<li>两大模式:    </li>
</ol>
<ul>
<li>图像混合模式<br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhrw6t4vjwj20l50dzdg2.jpg" alt="">  </li>
<li>Alpha合成模式<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhrw5o0q33j20le0homxm.jpg" alt=""> </li>
</ul>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/15/一起看画布Canvas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="洪荣宣">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ww1.sinaimg.cn/large/8992ce25gy1fengvigdatj205k05k0t0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rongxuanhong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/15/一起看画布Canvas/" itemprop="url">一起看画布Canvas</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-15T23:39:49+08:00">2017-07-15</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/15/一起看画布Canvas/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments:</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/15/一起看画布Canvas/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p><strong>版权声明：本文为博主原创文章，未经博主允许不得转载</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Canvas</code> 本意是画布的意思,然而将它理解为绘制工具一点也不为过。通过 <code>Canvas</code> 提供的  <strong>API</strong>，你可以在画布上绘制出绝大部分图形，再配合上一些操作画布的 <strong>API</strong>，比如旋转剪裁等变换画布的操作，就能够巧妙地画出更加复杂的图形。</p>
<h1 id="drawXXX系列"><a href="#drawXXX系列" class="headerlink" title="drawXXX系列"></a>drawXXX系列</h1><h2 id="canvas-drawArc"><a href="#canvas-drawArc" class="headerlink" title="canvas.drawArc"></a>canvas.drawArc</h2><ol>
<li><p>方法:  </p>
<pre><code> drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter,Paint paint)
 drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)
</code></pre></li>
<li>画的方向为顺时针</li>
<li><p>对参数的解释:</p>
<ul>
<li><strong>userCenter</strong> 若为true表示此弧会和 <code>RectF</code> 中心相连形成扇形，否则，弧的两头直接相连形成图形。</li>
<li><strong>startAngle</strong>，负数或大于360则对360模除。</li>
<li><strong>sweepAngle</strong>，大于360，则画出一圈。</li>
<li>角度：以 <code>RectF</code> 中心为坐标中心，中心所在直线为水平线，负角度弧斜上走，正角度弧斜下走,或者说以时钟三点钟为0度，顺时针为正，逆时针为负。  </li>
</ul>
</li>
<li><p>例子:  </p>
<pre><code> mPaint.setAntiAlias(true);
 mPaint.setColor(Color.RED);
 RectF mRecF=new RectF(20,20,200,200);
 canvas.drawArc(mRecF,-45,135,true,mPaint);//以斜上45度为起点，顺时针扫过135度
</code></pre></li>
</ol>
<ul>
<li><strong>useCenter</strong>=true<br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhkdaxydxnj208a09tglg.jpg" alt="">  </li>
<li><strong>useCenter</strong>=false<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkddhax22j208g09z0sl.jpg" alt=""></li>
</ul>
<h2 id="canvas-drawCircle"><a href="#canvas-drawCircle" class="headerlink" title="canvas.drawCircle"></a>canvas.drawCircle</h2><ol>
<li><p>方法:  </p>
<pre><code> drawCircle(float cx, float cy, float radius, Paint paint) 
</code></pre></li>
<li>对参数的解释:<ul>
<li><strong>cx,cy</strong> 为所画圆的中心坐标，<strong>radius</strong> 为圆的半径  </li>
</ul>
</li>
<li><p>例子  </p>
<pre><code> mPaint.setAntiAlias(true);
 mPaint.setColor(Color.RED);
 canvas.drawCircle(100,100,80,mPaint);   
</code></pre></li>
</ol>
<ul>
<li>圆心为（100，100），半径为80<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkdl5zl3xj208k08va9x.jpg" alt="">  </li>
</ul>
<ol>
<li><strong>注意：</strong> 当画笔设置了 <code>StrokeWidth</code> 时，圆的半径=内圆的半径+<code>StrokeWidth</code>/2  </li>
</ol>
<h2 id="canvas-drawBitmap"><a href="#canvas-drawBitmap" class="headerlink" title="canvas.drawBitmap"></a>canvas.drawBitmap</h2><ol>
<li><p>方法1: </p>
<pre><code> drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) 
</code></pre><p>对参数的解释:</p>
<ul>
<li><strong>bitmap</strong>:要画在画布上的位图</li>
<li><strong>matrix</strong>：构建的矩阵作用于将要画出的位图  </li>
</ul>
</li>
<li><p>方法2：</p>
<pre><code> drawBitmap(Bitmap bitmap, Rect src, RectF dst, Paint paint)
</code></pre><p>对参数的解释:</p>
<ul>
<li><strong>src</strong>:可为 <code>null</code>，表示画整个位图，否则只花出位图的一块矩形区域图.<strong>subset of bitmap</strong></li>
<li><strong>dst</strong>:定义的一个矩形范围，位图会平移或缩放来将自身放入矩形内  </li>
</ul>
</li>
<li><p>方法3:  </p>
<pre><code> drawBitmap(Bitmap bitmap, float left, float top, Paint paint)  
</code></pre></li>
<li><p>方法4： </p>
<pre><code> drawBitmapMesh(Bitmap bitmap, int meshWidth, int meshHeight, float[] verts, int vertOffset, int[] colors, int colorOffset, Paint paint) 
</code></pre><p>网格扭曲，水波等的绘制<br>知识：<a href="https://www.zybuluo.com/cxm-2016/note/506317" target="_blank" rel="noopener">https://www.zybuluo.com/cxm-2016/note/506317</a>  </p>
</li>
<li><p>例子:</p>
<ul>
<li><p>方法1:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  Matrix matrix = new Matrix();
  matrix.postTranslate(100,0);//左移100
  matrix.postRotate(45);//顺时针旋转45度
  canvas.drawBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher),matrix,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhkdykl9raj208c08gglj.jpg" alt="">  </p>
</li>
<li><p>方法2：  </p>
<pre><code>  Rect src = new Rect(20, 20, 40, 40);//取bitmap上src区域的部分图像
  Rect dst = new Rect(100, 100, 200, 200);//绘制的最终区域，一定填满
  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  canvas.drawBitmap(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher),src,dst,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhkemsmvrmj208n0943yc.jpg" alt="">  </p>
</li>
<li><p>方法3：  </p>
<pre><code>   canvas.drawBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher), 100, 100, mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkiibu7bej208r091a9x.jpg" alt="">  </p>
</li>
</ul>
</li>
</ol>
<h2 id="canvas-drawColor-drawRGB"><a href="#canvas-drawColor-drawRGB" class="headerlink" title="canvas.drawColor,drawRGB"></a>canvas.drawColor,drawRGB</h2><ol>
<li><p>方法：  </p>
<pre><code> drawColor(int color, PorterDuff.Mode mode) 
</code></pre><p>画整个画布的背景,但若区域受到剪裁，则只绘制剪裁区域的背景. 关键类 <code>PorterDuff.Mode</code>  </p>
</li>
<li>方法：<code>drawRGB(int r, int g, int b)</code><br>同上</li>
</ol>
<h2 id="canvas-drawLine-s"><a href="#canvas-drawLine-s" class="headerlink" title="canvas.drawLine(s)"></a>canvas.drawLine(s)</h2><ol>
<li><p>方法1： </p>
<pre><code> drawLine(float startX, float startY, float stopX, float stopY, Paint paint)
</code></pre><p>对参数的解释:</p>
<ul>
<li>前四个参数为直线的起点和终点的 <strong>XY</strong> 轴坐标  </li>
</ul>
</li>
<li><p>方法2：  </p>
<pre><code> drawLines(float[] pts,Paint paint)
</code></pre></li>
<li><p>方法3：</p>
<pre><code> drawLines(float[] pts, int offset, int count, Paint paint)  
</code></pre><p>对参数的解释：</p>
<ul>
<li><strong>pts</strong>:待画的坐标点数组，格式为(<strong>x1,y1,x2,y2,…</strong>),至少4个值</li>
<li><strong>offset</strong>:要跳过坐标点数组中几个值才开始画(必须是4的倍数)</li>
<li><strong>count</strong>:至少为2，<strong>offset</strong> 之后数组的大小。  </li>
</ul>
</li>
<li><p>例子  </p>
<ul>
<li><p>方法1:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(16);
  canvas.drawText(&quot;起点(20,100)&quot;, 22, 100, mPaint);
  canvas.drawText(&quot;终点(50,100)&quot;, 52, 150, mPaint);
  canvas.drawLine(20, 100, 50, 150, mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkhqxwiugj209u0a5q2u.jpg" alt="">  </p>
</li>
<li><p>方法2：  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(16);
  canvas.drawText(&quot;A1(20,100)&quot;, 0, 90, mPaint);
  canvas.drawText(&quot;A2(100,350)&quot;, 40, 370, mPaint);
  canvas.drawText(&quot;B1(100,100)&quot;, 80, 90, mPaint);
  canvas.drawText(&quot;B2(180,350)&quot;, 150, 370, mPaint);
  float[] points=new float[]{20,100,100,350,100,350,100,100,100,100,180,350};//至少4个值，即能够绘制一条直线
  canvas.drawLines(points,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhki2nfpkqj20930b9dfw.jpg" alt="">  </p>
</li>
<li><p>方法3:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(16);
  canvas.drawText(&quot;A1(100,350)&quot;, 40, 370, mPaint);
  canvas.drawText(&quot;B2(100,100)&quot;, 80, 90, mPaint);
  canvas.drawText(&quot;B3(180,350)&quot;, 150, 370, mPaint);
  float[] points=new float[]{20,100,100,350,100,350,100,100,100,100,180,350};//至少4个点
  canvas.drawLines(points,4,8,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhki5jfgn1j20950aqdft.jpg" alt="">  </p>
</li>
</ul>
</li>
</ol>
<h2 id="canvas-drawRect"><a href="#canvas-drawRect" class="headerlink" title="canvas.drawRect"></a>canvas.drawRect</h2><ol>
<li><p>方法1：</p>
<pre><code> void drawRect(float left, float top, float right, float bottom, Paint paint)  
</code></pre><p>确定矩形四个顶点的位置配上画笔即可  </p>
</li>
<li><p>方法2: </p>
<pre><code> void drawRect(Rect r, Paint paint) 
</code></pre><p>矩形的四个位置为整型时使用</p>
</li>
<li><p>方法3:  </p>
<pre><code> void drawRect(RectF r, Paint paint)  
</code></pre><p>方法1的另一简版，矩形的四个位置为浮点型时使用  </p>
</li>
<li><p>例子:  </p>
<pre><code> mPaint.setAntiAlias(true);
 mPaint.setColor(Color.RED);
 canvas.drawRect(new RectF(20f, 20f, 120f, 120f), mPaint);
 //canvas.drawRect(new Rect(20, 20, 120, 120), mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhknan9823j208m07gdfm.jpg" alt="">  </p>
</li>
</ol>
<h2 id="canvas-drawOval"><a href="#canvas-drawOval" class="headerlink" title="canvas.drawOval"></a>canvas.drawOval</h2><p>绘制椭圆<br>类似 <code>drawRect</code>  </p>
<h2 id="canvas-drawPaint"><a href="#canvas-drawPaint" class="headerlink" title="canvas.drawPaint"></a>canvas.drawPaint</h2><p>方法：<br>        <code>drawPaint(Paint paint)</code><br>自定义的 <code>paint</code> 画在整个画布上,等于用 <code>paint</code> 在画布上画一个无限大的矩形，但当前画布受到剪裁，则染色区域仅限于剪裁部分。</p>
<h2 id="canvas-drawPoint-s"><a href="#canvas-drawPoint-s" class="headerlink" title="canvas.drawPoint(s)"></a>canvas.drawPoint(s)</h2><p>绘制点，方法基本类似<code>drawLine(s)</code></p>
<h2 id="canvas-drawRoundRect"><a href="#canvas-drawRoundRect" class="headerlink" title="canvas.drawRoundRect"></a>canvas.drawRoundRect</h2><ol>
<li><p>方法1：  </p>
<pre><code> drawRoundRect(RectF rect, float rx, float ry, Paint paint)   
</code></pre></li>
<li><p>方法2: </p>
<pre><code> drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)  
</code></pre><p>对参数的解释：  </p>
<ul>
<li><strong>rx,ry</strong> 表示 <strong>left</strong> 到 <strong>left+rx</strong> 与 <strong>left</strong> 到 <strong>left+ry</strong> 所围区域做弧，其余三个角类似，当 <strong>rx=ry&gt;=(right-left)/2</strong> 时表示画一个半径为 <strong>rx(ry)</strong> 的圆（刚好外接一个矩形） </li>
</ul>
</li>
<li><p>例子  </p>
<ul>
<li><p>方法1:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  RectF mRecf = new RectF(20, 100, 200, 200);
  canvas.drawRoundRect(mRecf, 30, 50, mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhkir0hoogj208u08qweb.jpg" alt="">  </p>
</li>
<li>方法2:API level至少21，做法一样  </li>
</ul>
</li>
</ol>
<h2 id="canvas-drawText"><a href="#canvas-drawText" class="headerlink" title="canvas.drawText"></a>canvas.drawText</h2><ol>
<li><p>方法1: </p>
<pre><code> drawText(String text, float x, float y, Paint paint)  
</code></pre><p>在 <strong>x,y</strong> 位置开始画 <strong>text</strong><br><strong>注意</strong>：其中 <strong>y</strong> 表示文字的基线(<strong>baseline</strong> )所在的坐标,说白了就是我们小学写字用的那种带有横线的本子(一般都是按照一条基线来写字是吧？)，用于规范你写的字是否成一条直线，否则很多人写着写着就往上飘了。而 <strong>x</strong> 坐标就是文字绘制的起始水平坐标，但是每个文字本身两侧都有一定的间隙，故实际文字的位置会比 <strong>x</strong> 的位置再偏右侧一些。  </p>
</li>
<li>图:<br>基线类似下图深绿色的横线<br><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fi1xvfruh0j205101iq30.jpg" alt="">  </li>
<li><p>方法2：</p>
<pre><code> drawText(CharSequence text, int start, int end, float x, float y, Paint paint)  
</code></pre><p>在 <strong>x,y</strong> 位置上画出 <strong>start</strong> 到 <strong>end</strong>(不含 <strong>end</strong>) 之间的字符  <strong>CharSequence charSequence = “charSequence”;</strong></p>
</li>
<li><p>方法3： </p>
<pre><code> drawText(char[] text, int index, int count, float x, float y, Paint paint)  
</code></pre><p>对参数的解释:</p>
<ul>
<li><strong>index</strong>:表示从第几个字符开始，</li>
<li><strong>count</strong>:表示截取的数组长度</li>
<li>字符数组的定义: <strong>char[] a=”abc”.toCharArray()</strong> </li>
</ul>
</li>
<li><p>方法4： </p>
<pre><code> drawTextOnPath(String text, Path path, float hOffset, float vOffset, Paint paint)
</code></pre><p>对参数的解释:</p>
<ul>
<li><strong>path</strong>:文本绘制的路径（关键）</li>
<li><strong>hOffset</strong>:相对于路径的水平偏移量</li>
<li><strong>vOffset</strong>:相对于路径的垂直偏移量  </li>
</ul>
</li>
<li><p>方法5：</p>
<pre><code> drawTextOnPath(char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)  
</code></pre><p> 方法3和4的合体  </p>
</li>
<li><p>方法6： </p>
<pre><code> drawTextRun(CharSequence text, int start, int end, int contextStart, int contextEnd, float x, float y, boolean isRtl, Paint paint)  
</code></pre><p>对参数的解释：  </p>
<ul>
<li><strong>contextStart</strong>:可选，直接=start</li>
<li><strong>contextEnd</strong>：可选，直接=end</li>
<li><strong>x,y</strong>：文字绘制起点</li>
<li><strong>isRt1(isRightToLeft)</strong>:文字是否支持<strong>rtl</strong></li>
<li><code>0 &lt;= contextStart &lt;= start &lt;= end &lt;= contextEnd &lt;= text.length</code>  </li>
</ul>
</li>
<li><p>方法7：  </p>
<pre><code> drawTextRun(char[] text, int index, int count, int contextIndex, int contextCount, float x, float y, boolean isRtl, Paint paint)  
</code></pre><p>方法3和方法6合体</p>
<p> <code>count = end - start, contextCount = contextEnd - contextStart.</code> </p>
</li>
<li><p>例子:</p>
<ul>
<li><p>方法1：  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(20);
  canvas.drawText(&quot;Canvas学习&quot;,50,100,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhkiz81vydj209808yglg.jpg" alt="">  </p>
</li>
<li><p>方法2:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(20);
  CharSequence charSequence=&quot;Canvas学习&quot;;
  canvas.drawText(charSequence,1,charSequence.length(),30,50,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25ly1fhkj2jak50j20930a2dfo.jpg" alt="">  </p>
</li>
<li><p>方法3:  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(20);
  char[] chars=&quot;Canvas学习&quot;.toCharArray();
  canvas.drawText(chars,1,chars.length-1,30,50,mPaint);  
</code></pre><p>效果图同方法2  </p>
</li>
<li><p>方法4：  </p>
<pre><code>  mPaint.setAntiAlias(true);
  mPaint.setColor(Color.RED);
  mPaint.setTextSize(20);
  Path path=new Path();
  String text=&quot;Canvas学习&quot;;
  path.addCircle(100,100,50, Path.Direction.CCW);
  canvas.drawTextOnPath(text,path,0f,0f,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkjb2a4jrj209109iwec.jpg" alt=""></p>
</li>
</ul>
</li>
</ol>
<h2 id="canvas-drawPath"><a href="#canvas-drawPath" class="headerlink" title="canvas.drawPath"></a>canvas.drawPath</h2><p>方法:<code>drawPath(Path path, Paint paint)</code><br>根据定义的路径画出图<br>例子:  </p>
<pre><code>        mPaint.setAntiAlias(true);
        mPaint.setColor(Color.RED);
        Path path=new Path();
        path.addCircle(100,100,50, Path.Direction.CCW);
        canvas.drawPath(path,mPaint);  
</code></pre><p>效果等于画一个圆   </p>
<h1 id="canvas-clipxxx系列"><a href="#canvas-clipxxx系列" class="headerlink" title="canvas.clipxxx系列"></a>canvas.clipxxx系列</h1><h2 id="canvas-clipPath"><a href="#canvas-clipPath" class="headerlink" title="canvas.clipPath"></a>canvas.clipPath</h2><ol>
<li><p>方法1：</p>
<pre><code> clipPath(Path path)  
</code></pre><p>按所定义的路线剪裁,默认Region.Op.INTERSECT表示剪裁出相交的部分</p>
</li>
<li><p>方法2：</p>
<pre><code> clipPath(Path path, Region.Op op)  
</code></pre><p>解释：用指定的路径 <strong>path</strong> 修改当前的剪裁<br>对op参数的理解:以剪裁两次的区域分别为A，B来区别</p>
<ul>
<li><strong>Region.Op.DIFFERENCE</strong>:剪裁出差异的部分，类似 <strong>A-B</strong> 部分</li>
<li><strong>Region.Op.REPLACE</strong>:后剪裁B的覆盖剪裁的A</li>
<li><strong>Region.Op.REVERSE_DEFFERENCE</strong>:剪裁出差异的部分，类似 <strong>B-A</strong> 部分</li>
<li><strong>Region.Op.INTERSECT</strong>:剪裁出相交的部分，类似 <strong>A交B</strong> 部分</li>
<li><strong>Region.Op.UNION</strong>:剪裁出AB合并的部分，类似<strong> AUB</strong></li>
<li><strong>Region.Op.XOR</strong>：是<strong> (AUB)-(A交B)</strong> 刚好与<strong> A交B</strong> 相对</li>
</ul>
</li>
<li><p>方法3：</p>
<pre><code> clipRect(Rect[F] rect, Region.Op op)[]表示可选  
</code></pre><p>解释：用指定的矩形来修改当前的剪裁  </p>
</li>
<li><p>方法4：</p>
<pre><code> clipRect(Rect rect)  
</code></pre><p>剪裁一个矩形区域，还有其他能构造矩形的方法不再列出  </p>
</li>
<li><p>例子(以剪裁路径为例):<br>首次剪裁  </p>
<pre><code>     Path path=new Path();
     path.addCircle(100,100,50, Path.Direction.CCW);
     canvas.clipPath(path);
     canvas.clipPath(path);
     canvas.drawColor(Color.RED);//红色区域即为剪裁的区域  
</code></pre><p>由于 <strong>clipPath</strong> 方法剪裁模式默认为<strong>Region.Op.INTERSECT</strong>，故当前剪裁部分和整个画布相交即为本身。<br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkm5so2wxj2092091q2r.jpg" alt="">  </p>
</li>
<li><p>剪裁模式(绿色区域为最终得到的剪裁部分)  </p>
<pre><code> mPaint.setAntiAlias(true);
 mPaint.setColor(Color.RED);
 canvas.drawColor(Color.BLUE);
 canvas.drawRect(new RectF(20, 20, 120, 120), mPaint);
 canvas.drawCircle(120, 70, 50, mPaint);
 canvas.clipRect(new RectF(20, 20, 120, 120));
 Path path = new Path();
 path.addCircle(120, 70, 50, Path.Direction.CCW);
 canvas.clipPath(path, Region.Op.INTERSECT);
 canvas.drawColor(Color.GREEN);  
</code></pre></li>
</ol>
<ul>
<li><strong>Region.Op.INTERSECT</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkmtcumfzj208n09f0sk.jpg" alt="">  </li>
<li><strong>Region.Op.REPLACE</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkmunykaaj208f08gweb.jpg" alt="">  </li>
<li><strong>Region.Op.REVERSE_DEFFERENCE</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkmw0yqbrj208g08da9v.jpg" alt="">  </li>
<li><strong>Region.Op.UNION</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkmxdkq2aj208l08la9v.jpg" alt="">  </li>
<li><strong>Region.Op.XOR</strong><br><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkmylwokrj208a07tt8j.jpg" alt=""></li>
</ul>
<h1 id="canvas的保存与恢复"><a href="#canvas的保存与恢复" class="headerlink" title="canvas的保存与恢复"></a>canvas的保存与恢复</h1><ol>
<li>解释：用来保存或恢复 <code>Canvas</code> 的状态  </li>
<li>作用：<code>save</code> 之后可以调用 <code>Canvas</code> 的平移、放缩、旋转、错切、裁剪等对当前画布进行操作,再进行相应的绘制，避免影响画布上已绘制的 <code>view</code>，配合 <code>canvas.restore()</code>(将当前画布恢复到初始状态) 使用  </li>
</ol>
<h1 id="canvas的变幻操作"><a href="#canvas的变幻操作" class="headerlink" title="canvas的变幻操作"></a>canvas的变幻操作</h1><h2 id="canvas-translate"><a href="#canvas-translate" class="headerlink" title="canvas.translate"></a>canvas.translate</h2><ol>
<li><p>方法: </p>
<pre><code> canvas.translate(float dx, float dy)  
</code></pre><p>作用：移动当前画布水平距离 <strong>dx</strong>，竖直距离 <strong>dy</strong>  </p>
</li>
<li><p>例子:  </p>
<pre><code> mPaint.setAntiAlias(true);
 mPaint.setColor(Color.RED);
 canvas.drawColor(Color.BLUE);
 canvas.translate(100,100);
 canvas.drawCircle(0,0,50,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhknou7kvmj2085086web.jpg" alt="">  </p>
<h2 id="canvas-scale"><a href="#canvas-scale" class="headerlink" title="canvas.scale"></a>canvas.scale</h2></li>
<li><p>方法1: </p>
<pre><code> canvas.scale(float sx, float sy)  
</code></pre><p>作用：<strong>sx、sy</strong> 是 <strong>x、y</strong> 方向上缩放的倍数,画布缩放后，再画出的图片相应的坐标都会进行缩放  </p>
</li>
<li><p>例子:  </p>
<pre><code> mPaint.setAntiAlias(true);
 mPaint.setColor(Color.RED);
 canvas.drawColor(Color.BLUE);
 canvas.save();
 canvas.scale(0.5f,0.5f);//x,y均缩小一半
 canvas.drawCircle(100,100,50,mPaint);
 canvas.restore();
 mPaint.setColor(Color.WHITE);
 canvas.drawCircle(100,100,50,mPaint);  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkns0kgnjj208k081mx0.jpg" alt="">  </p>
</li>
<li><p>方法2: </p>
<pre><code> canvas.scale (float sx, float sy, float px, float py)  
</code></pre><p>作用:缩放画布并平移画布到基准点<strong>(px,py) </strong><br>对参数的解释:  </p>
<ul>
<li><strong>px,py</strong> 为缩放后画布新的坐标原点(也叫缩放基准点)  </li>
</ul>
</li>
<li><p>例子:  </p>
<pre><code> mPaint.setAntiAlias(true);
 canvas.drawColor(Color.BLUE);
 mPaint.setColor(Color.WHITE);
 canvas.drawCircle(100,100,50,mPaint);
 canvas.save();
 canvas.scale(0.5f,0.5f,100,100);
 mPaint.setColor(Color.RED);
 canvas.drawCircle(100,100,50,mPaint);
 canvas.restore();  
</code></pre></li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhknuznikij209408nq2s.jpg" alt=""></p>
<h2 id="canvas-rotate"><a href="#canvas-rotate" class="headerlink" title="canvas.rotate"></a>canvas.rotate</h2><ol>
<li><p>方法： </p>
<pre><code> canvas.rotate(float degrees)  
</code></pre><p>作用：顺时针旋转当前画布一定角度，也可加入基准点坐标  </p>
</li>
<li><p>例子：  </p>
<pre><code> mPaint.setAntiAlias(true);
 canvas.drawColor(Color.BLUE);
 mPaint.setColor(Color.WHITE);
 canvas.drawRect(new RectF(80,80,180,180),mPaint);
 canvas.save();
 canvas.rotate(45);
 //canvas.rotate(45,200,200);
 mPaint.setColor(Color.RED);
 canvas.drawRect(new RectF(80,80,180,180),mPaint);
 canvas.restore();  
</code></pre></li>
</ol>
<ul>
<li><p>无基准点  </p>
<p>  <img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhko1i33kfj208p09gweb.jpg" alt="">  </p>
</li>
<li><p>有基准点 (200，200)  </p>
<p>  <img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhko2cl6xaj208u094mx0.jpg" alt="">  </p>
<h2 id="canvas-skew"><a href="#canvas-skew" class="headerlink" title="canvas.skew"></a>canvas.skew</h2></li>
</ul>
<ol>
<li><p>方法: </p>
<pre><code> canvas.skew(float sx, float sy)  
</code></pre><p>作用:画布的错切</p>
</li>
</ol>
<ul>
<li><strong>sx</strong>:将画布在 <strong>x</strong> 方向上倾斜相应的角度，<strong>sx</strong> 为倾斜角度的 <strong>tan</strong> 值；</li>
<li><strong>sy</strong>:将画布在 <strong>y</strong> 轴方向上倾斜相应的角度，<strong>sy</strong> 为倾斜角度的 <strong>tan</strong> 值；<br>比如在 <strong>X</strong> 轴方向上倾斜45度，<strong>tan45=1</strong>;  </li>
</ul>
<ol>
<li><p>例子:  </p>
<pre><code> mPaint.setAntiAlias(true);
 canvas.drawColor(Color.BLUE);
 mPaint.setColor(Color.WHITE);
 canvas.drawRect(new RectF(0,0,180,180),mPaint);
 canvas.save();
 canvas.skew(1,0);//画布X轴倾斜45度
 mPaint.setColor(Color.RED);
 canvas.drawRect(new RectF(0,0,180,180),mPaint);
 canvas.restore();  
</code></pre><p><img src="http://ww1.sinaimg.cn/large/8992ce25gy1fhkpi1m3d6j209907xa9x.jpg" alt=""></p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上大致介绍了 <strong>Canvas</strong> 类中众多绘制方法。首先，先对方法进行解析；其次，给出相应的示例代码并结合运行效果，旨在帮助读者更好地理解诸如上述绘制方法的基本使用；最后，对于方法的理解如有纰漏，欢迎指正。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p><a href="https://developer.android.google.cn/reference/android/graphics/Canvas.html" target="_blank" rel="noopener">官方Canvas类API</a><br><a href="http://blog.csdn.net/tianjian4592/article/details/45234419" target="_blank" rel="noopener">Canvas之translate、scale、rotate、skew方法讲解</a></p>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://ww1.sinaimg.cn/large/8992ce25gy1fengvigdatj205k05k0t0.jpg"
                alt="洪荣宣" />
            
              <p class="site-author-name" itemprop="name">洪荣宣</p>
              <p class="site-description motion-element" itemprop="description">Rongxuanhong's Blog</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">68</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/rongxuanhong" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:francishongrx@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.jianshu.com/u/68e7b05458bc" target="_blank" title="简书"><i class="fa fa-fw fa-globe"></i>简书</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://blog.csdn.net/u013534680" target="_blank" title="CSDN"><i class="fa fa-fw fa-globe"></i>CSDN</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">洪荣宣</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="Total Visitors">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="Total Views">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.6"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.6"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.6"></script>



  



	





  





  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'PHg2RRIUgmj5CjX5xB2yjkbQ-gzGzoHsz',
        appKey: '3feashi2HbnYMycDoEQPqaIx',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    
  


  
  

  

  

  

  

  <!-- 页面点击小红心 start--> 
  <script type="text/javascript" src="/js/src/love.js"></script>
<!-- 页面点击小红心 end--> 

<!--崩溃欺骗-->
<script>
var OriginTitile = document.title;
 var titleTime;
 document.addEventListener('visibilitychange', function () {
     if (document.hidden) {
        // $('[rel="icon"]').attr('href', "/img/TEP.ico");
         document.title = '╭(°A°`)╮ 页面崩溃啦 ~ ';
         clearTimeout(titleTime);
     }
     else {
       //  $('[rel="icon"]').attr('href', "/favicon.ico");
         document.title = '(ฅ>ω<*ฅ) 噫又好了~' + OriginTitile;
         titleTime = setTimeout(function () {
             document.title = OriginTitile;
         }, 2000);
     }
 });
 </script>
</body>
</html>
